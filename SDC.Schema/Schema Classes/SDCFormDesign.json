{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "description": "Generated by xsd2code++. www.xsd2code.com",
  "definitions": {
    "ExtensionType": {
      "description": "Similar to the Schema type xs:anyType, but requires strict validation, and includes optional baseAttributes. Developer will need to declare a namespace and provide a Schema to validate the contents.",
      "type": "object"
    },
    "BaseType": {
      "type": "object",
      "properties": {
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object\r  name, used to provide the ability for programmatic manipulation of an\r  element.",
          "type": "object"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the\r  element, chosen from a standardized list of terms. Tokens are short alphanumeric\r  text strings, defined by the W3C Schema NMTOKEN specification, that are defined\r  in an Implementation Guide. The type xsd:NMTOKEN represents a single string\r  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -\r  ), underscores ( _ ), and colons ( : ). They may start with any of these\r  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be\r  specific for one or more kinds of SDC elements. Multiple tokens in the type\r  attribute should be separated by whitespace. Type tokens may be used to specify\r  special handling by an application, and are usually used to define form display\r  constraints, but may include other custom metadata as well. Style metadata\r  should generally be handled with @styleClass rather than @type. @type token\r  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,\r  _pageBreak-after, etc. @type metadata should generally not affect the\r  information content of a form.",
          "type": "object"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for\r  use with an external style sheet.",
          "type": "object"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential\r  order for elements in a template. This serves the purpose of providing a\r  definitive/original order to sections, questions, answer choices, etc., when\r  required for display purposes. This is important when the original XML ordering\r  may become disrupted due to the use of an implementation technology that does\r  not natively support ordering (e.g., object collections), and it can also\r  provide a check on the proper importing of the XML tree during\r  implementation.",
          "type": "object"
        }
      }
    },
    "CommentType": {
      "type": "object"
    },
    "anyType_DEtype": {
      "type": "object"
    },
    "anyURI_DEtype": {
      "type": "object"
    },
    "base64Binary_DEtype": {
      "type": "object"
    },
    "boolean_DEtype": {
      "type": "object"
    },
    "byte_DEtype": {
      "type": "object"
    },
    "date_DEtype": {
      "type": "object"
    },
    "dateTime_DEtype": {
      "type": "object"
    },
    "dateTimeStamp_DEtype": {
      "type": "object"
    },
    "dayTimeDuration_DEtype": {
      "type": "object"
    },
    "decimal_DEtype": {
      "type": "object"
    },
    "double_DEtype": {
      "type": "object"
    },
    "duration_DEtype": {
      "type": "object"
    },
    "float_DEtype": {
      "type": "object"
    },
    "gDay_DEtype": {
      "type": "object"
    },
    "gMonth_DEtype": {
      "type": "object"
    },
    "gMonthDay_DEtype": {
      "type": "object"
    },
    "gYear_DEtype": {
      "type": "object"
    },
    "gYearMonth_DEtype": {
      "type": "object"
    },
    "hexBinary_DEtype": {
      "type": "object"
    },
    "HTML_DEtype": {
      "type": "object"
    },
    "int_DEtype": {
      "type": "object"
    },
    "integer_DEtype": {
      "type": "object"
    },
    "long_DEtype": {
      "type": "object"
    },
    "negativeInteger_DEtype": {
      "type": "object"
    },
    "nonNegativeInteger_DEtype": {
      "type": "object"
    },
    "nonPositiveInteger_DEtype": {
      "type": "object"
    },
    "positiveInteger_DEtype": {
      "type": "object"
    },
    "short_DEtype": {
      "type": "object"
    },
    "string_DEtype": {
      "type": "object"
    },
    "time_DEtype": {
      "type": "object"
    },
    "unsignedByte_DEtype": {
      "type": "object"
    },
    "unsignedInt_DEtype": {
      "type": "object"
    },
    "unsignedLong_DEtype": {
      "type": "object"
    },
    "unsignedShort_DEtype": {
      "type": "object"
    },
    "XML_DEtype": {
      "type": "object"
    },
    "yearMonthDuration_DEtype": {
      "type": "object"
    },
    "anyURI_Stype": {
      "type": "object"
    },
    "base64Binary_Stype": {
      "type": "object"
    },
    "boolean_Stype": {
      "type": "object"
    },
    "byte_Stype": {
      "type": "object"
    },
    "date_Stype": {
      "type": "object"
    },
    "dateTime_Stype": {
      "type": "object"
    },
    "dateTimeStamp_Stype": {
      "type": "object"
    },
    "dayTimeDuration_Stype": {
      "type": "object"
    },
    "decimal_Stype": {
      "type": "object"
    },
    "double_Stype": {
      "type": "object"
    },
    "duration_Stype": {
      "type": "object"
    },
    "float_Stype": {
      "type": "object"
    },
    "gDay_Stype": {
      "type": "object"
    },
    "gMonth_Stype": {
      "type": "object"
    },
    "gMonthDay_Stype": {
      "type": "object"
    },
    "gYear_Stype": {
      "type": "object"
    },
    "gYearMonth_Stype": {
      "type": "object"
    },
    "hexBinary_Stype": {
      "type": "object"
    },
    "HTML_Stype": {
      "type": "object"
    },
    "int_Stype": {
      "type": "object"
    },
    "integer_Stype": {
      "type": "object"
    },
    "long_Stype": {
      "type": "object"
    },
    "negativeInteger_Stype": {
      "type": "object"
    },
    "nonNegativeInteger_Stype": {
      "type": "object"
    },
    "nonPositiveInteger_Stype": {
      "type": "object"
    },
    "positiveInteger_Stype": {
      "type": "object"
    },
    "short_Stype": {
      "type": "object"
    },
    "string_Stype": {
      "type": "object"
    },
    "time_Stype": {
      "type": "object"
    },
    "unsignedByte_Stype": {
      "type": "object"
    },
    "unsignedInt_Stype": {
      "type": "object"
    },
    "unsignedLong_Stype": {
      "type": "object"
    },
    "unsignedShort_Stype": {
      "type": "object"
    },
    "XML_Stype": {
      "type": "object"
    },
    "yearMonthDuration_Stype": {
      "type": "object"
    },
    "NumericConstantsType111": {
      "type": "object",
      "properties": {
        "constant": {
          "type": "object"
        }
      }
    },
    "URI_Atype": {
      "type": "string",
      "minLength": 1
    },
    "URL_Atype": {
      "type": "string",
      "minLength": 1
    },
    "DataTypeNumeric_StypeEnum": {
      "type": "string",
      "enum": [
        "byte",
        "decimal",
        "double",
        "float",
        "hexbinary",
        "int",
        "integer",
        "long",
        "negativeInteger",
        "nonNegativeInteger",
        "nonPositiveInteger",
        "positiveInteger",
        "short",
        "unsignedByte",
        "unsignedInt",
        "unsignedLong",
        "unsignedShort"
      ]
    },
    "DataTypeInteger_StypeEnum": {
      "type": "string",
      "enum": [
        "byte",
        "int",
        "integer",
        "long",
        "negativeInteger",
        "nonNegativeInteger",
        "nonPositiveInteger",
        "positiveInteger",
        "short",
        "unsignedByte",
        "unsignedInt",
        "unsignedLong",
        "unsignedShort"
      ]
    },
    "DataTypeDateTime_StypeEnum": {
      "type": "string",
      "enum": [
        "dateTime",
        "duration",
        "gMonthDay",
        "gYear",
        "gYearMonth",
        "time",
        "yearMonthDuration",
        "unsignedShort"
      ]
    },
    "DataTypeString_StypeEnum": {
      "type": "string",
      "enum": [
        "string"
      ]
    },
    "DataTypeBoolean_StypeEnum": {
      "type": "string",
      "enum": [
        "boolean"
      ]
    },
    "DataTypeCustomClass_StypeEnum": {
      "type": "object",
      "enum": [
        "customClassName"
      ]
    },
    "DataTypeAll_StypeEnum": {},
    "ItemTarget": {
      "description": "A pointer to an element or attribute in an XML document.",
      "type": "object"
    },
    "BlobType": {
      "description": "Standard structure for including Binary Large Objects (Blobs) in XML\r  templates. Blobs can handle any type of binary media, such as images, audio, video,\r  and data streams of any specified format (such as a MIME type).",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Description": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RichTextType"
          }
        },
        "Hash": {
          "$ref": "#/definitions/HashType"
        },
        "BlobURI": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "BinaryMediaBase64": {
          "items": {
            "$ref": "#/definitions/base64Binary_Stype"
          }
        }
      }
    },
    "CodingType": {
      "description": "This type represents any type of coding, terminology, classification, keyword, or local value system that may be applied to any displayable item in a\r  FormDesign template.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Code": {
          "$ref": "#/definitions/string_Stype"
        },
        "TypedValue": {
          "$ref": "#/definitions/DataTypes_SType"
        },
        "CodeText": {
          "$ref": "#/definitions/RichTextType"
        },
        "CodeMatch": {
          "$ref": "#/definitions/CodeMatchType"
        },
        "CodeSystem": {
          "$ref": "#/definitions/CodeSystemType"
        },
        "CodeURI": {
          "$ref": "#/definitions/anyURI_Stype"
        },
        "Units": {
          "$ref": "#/definitions/UnitsType"
        }
      },
      "required": [
        "Code"
      ]
    },
    "CodeSystemType": {
      "description": "This type represents information about the coding system used in CodingType. It may refer to any type of coding, terminology, classification, keyword, or local value system.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "CodeSystemName": {
          "$ref": "#/definitions/string_Stype"
        },
        "ReleaseDate": {
          "$ref": "#/definitions/dateTime_Stype"
        },
        "Version": {
          "$ref": "#/definitions/string_Stype"
        },
        "OID": {
          "$ref": "#/definitions/string_Stype"
        },
        "CodeSystemURI": {
          "$ref": "#/definitions/anyURI_Stype"
        }
      },
      "required": [
        "CodeSystemName"
      ]
    },
    "ContactType": {
      "description": "A model structure for a Person or Organization that generally performs a particular stated role.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Person": {
          "$ref": "#/definitions/PersonType"
        },
        "Organization": {
          "$ref": "#/definitions/OrganizationType"
        }
      }
    },
    "PersonType": {
      "description": "A model structure for a Person object.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "PersonName": {
          "$ref": "#/definitions/NameType"
        },
        "AliasName": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NameType"
          }
        },
        "Job": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/JobType"
          }
        },
        "StreetAddress": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AddressType"
          }
        },
        "Email": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EmailType"
          }
        },
        "Phone": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PhoneType"
          }
        },
        "WebURL": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "Role": {
          "$ref": "#/definitions/string_Stype"
        },
        "Identifier": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/IdentifierType"
          }
        },
        "Usage": {
          "$ref": "#/definitions/string_Stype"
        }
      },
      "required": [
        "PersonName"
      ]
    },
    "JobType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "JobTitle": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "Organization": {
          "$ref": "#/definitions/OrganizationType"
        },
        "StartDate": {
          "$ref": "#/definitions/date_Stype"
        },
        "StopDate": {
          "$ref": "#/definitions/date_Stype"
        },
        "Description": {
          "$ref": "#/definitions/string_Stype"
        }
      }
    },
    "OrganizationType": {
      "description": "A model structure for an Organization object.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "OrgName": {
          "$ref": "#/definitions/string_Stype"
        },
        "Department": {
          "$ref": "#/definitions/string_Stype"
        },
        "StreetAddress": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AddressType"
          }
        },
        "Email": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EmailType"
          }
        },
        "Phone": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PhoneType"
          }
        },
        "WebURL": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "Role": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "ContactPerson": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PersonType"
          }
        },
        "Identifier": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/IdentifierType"
          }
        },
        "Usage": {
          "$ref": "#/definitions/string_Stype"
        }
      },
      "required": [
        "OrgName"
      ]
    },
    "AddressType": {
      "description": "A structure for recording street/mailing addresses.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "AddressType": {
          "$ref": "#/definitions/string_Stype"
        },
        "InternalAddress": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          },
          "maxItems": 10
        },
        "AddressLine": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          },
          "maxItems": 10
        },
        "City": {
          "$ref": "#/definitions/string_Stype"
        },
        "Jurisdiction": {
          "$ref": "#/definitions/string_Stype"
        },
        "State": {
          "$ref": "#/definitions/string_Stype"
        },
        "PostalCode": {
          "$ref": "#/definitions/string_Stype"
        },
        "Country": {
          "$ref": "#/definitions/string_Stype"
        },
        "Usage": {
          "$ref": "#/definitions/string_Stype"
        }
      }
    },
    "PhoneType": {
      "description": "A structure for recording telephone numbers.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "PhoneType": {
          "$ref": "#/definitions/string_Stype"
        },
        "CountryCode": {
          "$ref": "#/definitions/CountryCodeType"
        },
        "AreaCode": {
          "$ref": "#/definitions/AreaCodeType"
        },
        "PhoneNumber": {
          "$ref": "#/definitions/PhoneNumberType"
        },
        "PhoneExtension": {
          "$ref": "#/definitions/string_Stype"
        },
        "Usage": {
          "$ref": "#/definitions/string_Stype"
        }
      },
      "required": [
        "PhoneNumber"
      ]
    },
    "EmailType": {
      "description": "A structure for recording email addresses.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "EmailAddress": {
          "$ref": "#/definitions/EmailAddressType"
        },
        "EmailClass": {
          "$ref": "#/definitions/string_Stype"
        },
        "Usage": {
          "$ref": "#/definitions/string_Stype"
        }
      },
      "required": [
        "EmailAddress"
      ]
    },
    "FileType": {
      "description": "Information about a file, usually thought of as a binary byte stream\r  stored on disk. A FileType can also represent a \"virtual\" file, such as an XML\r  module in a larger XML document. Such a virtual file could theoretically be stored\r  as a byte stream, as an independant file on disk or as a database record or set of\r  records, even if this byte stream is never actually persisted as an independant disk\r  file.",
      "type": "object"
    },
    "LanguageType": {
      "description": "A generic structure for recording languages.",
      "type": "object"
    },
    "VersionType": {
      "description": "A generic structure for recording file version metadata.",
      "type": "object"
    },
    "AcceptabilityType": {
      "type": "object"
    },
    "ChangeLogType": {
      "description": "Inforamtion about changes to file or part of a\r  file.",
      "type": "object"
    },
    "ChangeType": {
      "description": "A structure to describe a single change in an XML document",
      "type": "object"
    },
    "FileDatesType": {
      "description": "List of standard kinds of dates that may apply to a file or its usage.",
      "type": "object"
    },
    "RichTextType": {
      "description": "Representation of plain text with an option for HTML-formatting. Contains optional boilerplate metadata to aid programmatic manipulation. HTML formatting is generally contained in CDATA tags to prevent XML parsing and schema errors.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "RichText": {
          "$ref": "#/definitions/HTML_Stype"
        }
      },
      "required": [
        "RichText"
      ]
    },
    "LinkType": {
      "description": "A hyperlink to an Internet endpoint such as a web page or web service.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "LinkText": {
          "$ref": "#/definitions/RichTextType"
        },
        "LinkURI": {
          "$ref": "#/definitions/anyURI_Stype"
        }
      },
      "required": [
        "LinkURI"
      ]
    },
    "UnitsType": {
      "description": "UnitsType represents the measurement standard and its abbreviated notation for quantifiable objects, e.g., miles, km, mm, cm, etc. The default system for standard notations is UCUM.",
      "type": "object"
    },
    "SubmissionRuleType": {
      "description": "information about where to submit a completed form",
      "type": "object"
    },
    "ComplianceRuleType": {
      "description": "General information about how information in a particular form package must be handled. This may include, e.g., security, completeness, transmission, and validation criteria.",
      "type": "object"
    },
    "EmailAddressType": {
      "description": "***Changed from BaseType to ExtensionBaseType",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "PhoneNumberType": {
      "description": "***Changed from BaseType to ExtensionBaseType",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "AreaCodeType": {
      "type": "object"
    },
    "CountryCodeType": {
      "type": "object"
    },
    "LanguageCode.ISO.639.3_Type": {
      "type": "object"
    },
    "NameType": {
      "description": "Structure to define a person's name, including prefixes, suffixes, and degrees.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "NamePrefix": {
          "$ref": "#/definitions/string_Stype"
        },
        "FirstName": {
          "$ref": "#/definitions/string_Stype"
        },
        "MiddleName": {
          "$ref": "#/definitions/string_Stype"
        },
        "LastName": {
          "$ref": "#/definitions/string_Stype"
        },
        "NameSuffix": {
          "$ref": "#/definitions/string_Stype"
        },
        "DegreeCert": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "Title": {
          "$ref": "#/definitions/string_Stype"
        }
      },
      "required": [
        "FirstName",
        "LastName"
      ]
    },
    "IdentifierType": {
      "description": "A code or id that identifies a person or organization or object according to a standard system such as CLIA or NPI. The system should be specified in the @system attribute.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "IdentifiedExtensionType": {
      "description": "This is the base type for all subtypes that require a unique URI identifier.",
      "type": "object"
    },
    "TargetItemIDType": {
      "type": "object"
    },
    "TargetItemNameType": {
      "type": "object"
    },
    "TargetItemXPathType": {
      "type": "object"
    },
    "CodeMatchType": {
      "type": "object",
      "properties": {
        "CodingMatchComment": {
          "$ref": "#/definitions/string_Stype"
        }
      }
    },
    "DestinationType": {
      "description": "***Changed from BaseType to ExtensionBaseType",
      "type": "object"
    },
    "FileUsageType": {
      "type": "object"
    },
    "ContactsType": {
      "type": "object"
    },
    "ApprovalType": {
      "type": "object"
    },
    "FileHashType": {
      "type": "object"
    },
    "AssociatedFilesType": {
      "type": "object"
    },
    "ProvenanceType": {
      "type": "object"
    },
    "ReplacedIDsType": {
      "type": "object"
    },
    "ChangeTrackingType": {
      "type": "object"
    },
    "ChangedFieldType": {
      "type": "object"
    },
    "HashType": {
      "type": "object"
    },
    "PropertyType1": {
      "description": "MOVED: From SDCFormDesign\r CHANGED:\r Property is any type of data that is associated with any form item (e.g., section, question, list item) in any context. The Property context is specified by the @type attribute. Examples of @type values may include:\r -alternate language representations, e.g., 'spanish'\r -'instruction'\r -'tooltip' \r -'help' for a pop-up help box\r -'outlining' (such as question numbering)\r \r The @type enumerations must be defined and documented for the particular use case, and are currently out of scope in this schema definition. Multiple type tokens for a single element are supported.\r \r RENAMED: 'OtherText' to 'Property' 9/14/2016",
      "type": "object"
    },
    "PropertyType": {
      "description": "MOVED: From SDCFormDesign\r CHANGED:\r Property is any type of data that is associated with any form item (e.g., section, question, list item) in any context. The Property context is specified by the @type attribute. Examples of @type values may include:\r -alternate language representations, e.g., 'spanish'\r -'instruction'\r -'tooltip' \r -'help' for a pop-up help box\r -'outlining' (such as question numbering)\r \r The @type enumerations must be defined and documented for the particular use case, and are currently out of scope in this schema definition. Multiple type tokens for a single element are supported.\r \r RENAMED: 'OtherText' to 'Property' 9/14/2016",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "TypedValue": {
          "$ref": "#/definitions/DataTypes_SType"
        }
      }
    },
    "ExtensionBaseType": {
      "type": "object"
    },
    "DataTypes_DEType": {
      "description": "MOVED from SDCDataTypes:\r SDC datatypes for Data Entry (DE), based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. Includes additonal metadata to specify data input restrictions for data entry forms, and to aid in validation of IHE RFD SubmitForm responses in XML instance documents.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "anyType": {
          "items": {
            "$ref": "#/definitions/anyType_DEtype"
          }
        },
        "anyURI": {
          "items": {
            "$ref": "#/definitions/anyURI_DEtype"
          }
        },
        "base64Binary": {
          "items": {
            "$ref": "#/definitions/base64Binary_DEtype"
          }
        },
        "boolean": {
          "items": {
            "$ref": "#/definitions/boolean_DEtype"
          }
        },
        "duration": {
          "items": {
            "$ref": "#/definitions/duration_DEtype"
          }
        },
        "byte": {
          "items": {
            "$ref": "#/definitions/byte_DEtype"
          }
        },
        "date": {
          "items": {
            "$ref": "#/definitions/date_DEtype"
          }
        },
        "dateTimeStamp": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_DEtype"
          }
        },
        "decimal": {
          "items": {
            "$ref": "#/definitions/decimal_DEtype"
          }
        },
        "dateTime": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_DEtype"
          }
        },
        "double": {
          "items": {
            "$ref": "#/definitions/double_DEtype"
          }
        },
        "float": {
          "items": {
            "$ref": "#/definitions/float_DEtype"
          }
        },
        "gDay": {
          "items": {
            "$ref": "#/definitions/gDay_DEtype"
          }
        },
        "gMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_DEtype"
          }
        },
        "gMonthDay": {
          "items": {
            "$ref": "#/definitions/gMonthDay_DEtype"
          }
        },
        "gYear": {
          "items": {
            "$ref": "#/definitions/gYear_DEtype"
          }
        },
        "gYearMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_DEtype"
          }
        },
        "hexBinary": {
          "items": {
            "$ref": "#/definitions/hexBinary_DEtype"
          }
        },
        "HTML": {
          "items": {
            "$ref": "#/definitions/HTML_DEtype"
          }
        },
        "int": {
          "items": {
            "$ref": "#/definitions/int_DEtype"
          }
        },
        "integer": {
          "items": {
            "$ref": "#/definitions/integer_DEtype"
          }
        },
        "long": {
          "items": {
            "$ref": "#/definitions/long_DEtype"
          }
        },
        "negativeInteger": {
          "items": {
            "$ref": "#/definitions/negativeInteger_DEtype"
          }
        },
        "nonNegativeInteger": {
          "items": {
            "$ref": "#/definitions/nonNegativeInteger_DEtype"
          }
        },
        "nonPositiveInteger": {
          "items": {
            "$ref": "#/definitions/nonPositiveInteger_DEtype"
          }
        },
        "positiveInteger": {
          "items": {
            "$ref": "#/definitions/positiveInteger_DEtype"
          }
        },
        "short": {
          "items": {
            "$ref": "#/definitions/short_DEtype"
          }
        },
        "string": {
          "items": {
            "$ref": "#/definitions/string_DEtype"
          }
        },
        "time": {
          "items": {
            "$ref": "#/definitions/time_DEtype"
          }
        },
        "unsignedByte": {
          "items": {
            "$ref": "#/definitions/unsignedByte_DEtype"
          }
        },
        "unsignedInt": {
          "items": {
            "$ref": "#/definitions/unsignedInt_DEtype"
          }
        },
        "unsignedLong": {
          "items": {
            "$ref": "#/definitions/unsignedLong_DEtype"
          }
        },
        "unsignedShort": {
          "items": {
            "$ref": "#/definitions/unsignedShort_DEtype"
          }
        },
        "XML": {
          "items": {
            "$ref": "#/definitions/XML_DEtype"
          }
        },
        "yearMonthDuration": {
          "items": {
            "$ref": "#/definitions/yearMonthDuration_DEtype"
          }
        }
      }
    },
    "DataTypesNumeric_DEType": {
      "description": "NEW:\r SDC datatypes for Data Entry (DE), based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. Includes additonal metadata to specify data input restrictions for data entry forms, and to aid in validation of IHE RFD SubmitForm responses in XML instance documents.",
      "type": "object"
    },
    "DataTypesNumeric_SType": {
      "description": "NEW:\r SDC datatypes in Simple (S) format, based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. **CHECK for ERRORS and completeness**",
      "type": "object"
    },
    "DataTypesDateTime_DEType": {
      "description": "NEW:\r SDC datatypes for Data Entry (DE), based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. Includes additonal metadata to specify data input restrictions for data entry forms, and to aid in validation of IHE RFD SubmitForm responses in XML instance documents.",
      "type": "object"
    },
    "DataTypesDateTime_SType": {
      "description": "NEW:\r SDC datatypes in Simple (S) format, based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. **CHECK for ERRORS and completeness**",
      "type": "object"
    },
    "DataTypes_SType": {
      "description": "MOVED from SDCDataTypes:\r SDC datatypes in Simple (S) format, based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. **CHECK for ERRORS and completeness**",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "anyType": {
          "items": {
            "$ref": "#/definitions/anyType_DEtype"
          }
        },
        "anyURI": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "base64Binary": {
          "items": {
            "$ref": "#/definitions/base64Binary_Stype"
          }
        },
        "boolean": {
          "items": {
            "$ref": "#/definitions/boolean_Stype"
          }
        },
        "duration": {
          "items": {
            "$ref": "#/definitions/duration_Stype"
          }
        },
        "byte": {
          "items": {
            "$ref": "#/definitions/byte_Stype"
          }
        },
        "date": {
          "items": {
            "$ref": "#/definitions/date_Stype"
          }
        },
        "dateTimeStamp": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_Stype"
          }
        },
        "decimal": {
          "items": {
            "$ref": "#/definitions/decimal_Stype"
          }
        },
        "dateTime": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_Stype"
          }
        },
        "double": {
          "items": {
            "$ref": "#/definitions/double_Stype"
          }
        },
        "float": {
          "items": {
            "$ref": "#/definitions/float_Stype"
          }
        },
        "gDay": {
          "items": {
            "$ref": "#/definitions/gDay_Stype"
          }
        },
        "gMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_Stype"
          }
        },
        "gMonthDay": {
          "items": {
            "$ref": "#/definitions/gMonthDay_Stype"
          }
        },
        "gYear": {
          "items": {
            "$ref": "#/definitions/gYear_Stype"
          }
        },
        "gYearMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_Stype"
          }
        },
        "hexBinary": {
          "items": {
            "$ref": "#/definitions/hexBinary_Stype"
          }
        },
        "HTML": {
          "items": {
            "$ref": "#/definitions/HTML_Stype"
          }
        },
        "int": {
          "items": {
            "$ref": "#/definitions/int_Stype"
          }
        },
        "integer": {
          "items": {
            "$ref": "#/definitions/integer_Stype"
          }
        },
        "long": {
          "items": {
            "$ref": "#/definitions/long_Stype"
          }
        },
        "negativeInteger": {
          "items": {
            "$ref": "#/definitions/negativeInteger_Stype"
          }
        },
        "nonNegativeInteger": {
          "items": {
            "$ref": "#/definitions/nonNegativeInteger_Stype"
          }
        },
        "nonPositiveInteger": {
          "items": {
            "$ref": "#/definitions/nonPositiveInteger_Stype"
          }
        },
        "positiveInteger": {
          "items": {
            "$ref": "#/definitions/positiveInteger_Stype"
          }
        },
        "short": {
          "items": {
            "$ref": "#/definitions/short_Stype"
          }
        },
        "string": {
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "time": {
          "items": {
            "$ref": "#/definitions/time_Stype"
          }
        },
        "unsignedByte": {
          "items": {
            "$ref": "#/definitions/unsignedByte_Stype"
          }
        },
        "unsignedInt": {
          "items": {
            "$ref": "#/definitions/unsignedInt_Stype"
          }
        },
        "unsignedLong": {
          "items": {
            "$ref": "#/definitions/unsignedLong_Stype"
          }
        },
        "unsignedShort": {
          "items": {
            "$ref": "#/definitions/unsignedShort_Stype"
          }
        },
        "XML": {
          "items": {
            "$ref": "#/definitions/XML_Stype"
          }
        },
        "yearMonthDuration": {
          "items": {
            "$ref": "#/definitions/yearMonthDuration_Stype"
          }
        }
      }
    },
    "ItemNameType": {
      "description": "Moved from SDCFormDesign\r The type is a standard way to point to a named item anywhere in a FormDesign template. A named item is any element that has the @name attribute set to a unique value.",
      "type": "object"
    },
    "ItemNameAttributeType": {
      "description": "Moved from SDCFormDesign\r The type is a standard way to point to a named item anywhere in a FormDesign template. A named item is any element that has the @name attribute set to a unique value.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "Acceptability_StypeEnum": {
      "description": "Enumeration for specifying the level of aceptability for SDC form items.",
      "type": "string",
      "enum": [
        "preferred",
        "admitted",
        "deprecated",
        "obsolete",
        "superseded"
      ]
    },
    "EmailAddress_Stype": {
      "type": "string",
      "pattern": "[a-zA-Z0-9_\\-\\.\\+-]+@[a-zA-Z0-9\\-]+\\.[a-zA-Z0-9_\\-\\.]+"
    },
    "PhoneNumber_Stype": {
      "type": "string",
      "pattern": "\\+?\\(?\\d{2,4}\\)?[\\d\\s-]{3,}"
    },
    "AreaCode_Stype": {
      "type": "object",
      "maximum": 999.0
    },
    "CountryCode_Stype": {
      "type": "object",
      "maximum": 99.0
    },
    "LanguageCode.ISO.639.3_StypeEnum": {
      "description": "Based on ISO-639-3 Language Codes. See:\r  https://en.wikipedia.org/wiki/ISO_639:e",
      "type": "string",
      "enum": [
        "eng",
        "esp",
        "fra"
      ]
    },
    "ParameterGroup": {
      "type": "object"
    },
    "ParameterItemType": {
      "description": "Parameters are named, uniquely identifiable, instances of form properties (e.g., @selected). They are fed into expressions, which are then used as part of a rule within the form. Parameters can also be fed into URI expressions used inside a Lookup Endpoint, i.e., URIs that call web services to supply list items (e.g., a list of SNOMED-coded items) to a question.\r \r Parameters using this construct are derived from other locations in the XML instance document, including user-entered Response values.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "ParameterValueType": {
      "description": "This type describes strongly-typed parameters used in functions and web services. Values are hard-coded as constants in the XML instance document. They are not user-entered values.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "anyType": {
          "items": {
            "$ref": "#/definitions/anyType_DEtype"
          }
        },
        "anyURI": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "base64Binary": {
          "items": {
            "$ref": "#/definitions/base64Binary_Stype"
          }
        },
        "boolean": {
          "items": {
            "$ref": "#/definitions/boolean_Stype"
          }
        },
        "duration": {
          "items": {
            "$ref": "#/definitions/duration_Stype"
          }
        },
        "byte": {
          "items": {
            "$ref": "#/definitions/byte_Stype"
          }
        },
        "date": {
          "items": {
            "$ref": "#/definitions/date_Stype"
          }
        },
        "dateTimeStamp": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_Stype"
          }
        },
        "decimal": {
          "items": {
            "$ref": "#/definitions/decimal_Stype"
          }
        },
        "dateTime": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_Stype"
          }
        },
        "double": {
          "items": {
            "$ref": "#/definitions/double_Stype"
          }
        },
        "float": {
          "items": {
            "$ref": "#/definitions/float_Stype"
          }
        },
        "gDay": {
          "items": {
            "$ref": "#/definitions/gDay_Stype"
          }
        },
        "gMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_Stype"
          }
        },
        "gMonthDay": {
          "items": {
            "$ref": "#/definitions/gMonthDay_Stype"
          }
        },
        "gYear": {
          "items": {
            "$ref": "#/definitions/gYear_Stype"
          }
        },
        "gYearMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_Stype"
          }
        },
        "hexBinary": {
          "items": {
            "$ref": "#/definitions/hexBinary_Stype"
          }
        },
        "HTML": {
          "items": {
            "$ref": "#/definitions/HTML_Stype"
          }
        },
        "int": {
          "items": {
            "$ref": "#/definitions/int_Stype"
          }
        },
        "integer": {
          "items": {
            "$ref": "#/definitions/integer_Stype"
          }
        },
        "long": {
          "items": {
            "$ref": "#/definitions/long_Stype"
          }
        },
        "negativeInteger": {
          "items": {
            "$ref": "#/definitions/negativeInteger_Stype"
          }
        },
        "nonNegativeInteger": {
          "items": {
            "$ref": "#/definitions/nonNegativeInteger_Stype"
          }
        },
        "nonPositiveInteger": {
          "items": {
            "$ref": "#/definitions/nonPositiveInteger_Stype"
          }
        },
        "positiveInteger": {
          "items": {
            "$ref": "#/definitions/positiveInteger_Stype"
          }
        },
        "short": {
          "items": {
            "$ref": "#/definitions/short_Stype"
          }
        },
        "string": {
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "time": {
          "items": {
            "$ref": "#/definitions/time_Stype"
          }
        },
        "unsignedByte": {
          "items": {
            "$ref": "#/definitions/unsignedByte_Stype"
          }
        },
        "unsignedInt": {
          "items": {
            "$ref": "#/definitions/unsignedInt_Stype"
          }
        },
        "unsignedLong": {
          "items": {
            "$ref": "#/definitions/unsignedLong_Stype"
          }
        },
        "unsignedShort": {
          "items": {
            "$ref": "#/definitions/unsignedShort_Stype"
          }
        },
        "XML": {
          "items": {
            "$ref": "#/definitions/XML_Stype"
          }
        },
        "yearMonthDuration": {
          "items": {
            "$ref": "#/definitions/yearMonthDuration_Stype"
          }
        }
      }
    },
    "FuncBoolBaseType": {
      "description": "Function or web service that returns a Boolean value. Items that inherit from this class must test the result for being a Boolean true/false value or null.",
      "type": "object"
    },
    "CallBoolFuncType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "ScriptCodeBoolType": {
      "description": "Programming code or pseudocode that describes a calculation. The code returns a value of the data type required by the parent Response field. To assist with enabling the code in the form, the referenced form items and properties should be referenced by @name under the parameters elemeent. It is possible to add mulitple calculation expressions to produce equivalent results using different programming languages and URIs. The @ type attribute may be used to distinguish between them. An Extension may be used instead of or along with an Expression and Parameters list. Expressions may populate Responses that are set to @readOnly = \"true\" to ensure that all responses are calculated and not latered by the user. Alternatively, the user may change a value created by (or instead of) the Expression.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Parameter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ParameterItemType"
          }
        }
      }
    },
    "ScriptCodeAnyType": {
      "description": "Programming code or pseudocode that describes a calculation. THe code returns a value of the data type required by the parent Response field. To assist with enabling the code in the form, the referenced form items and properties should be referenced by @name under the parameters elemeent. It is possible to add mulitple calculation expressions to produce equivalent results using different programming languages and URIs. The @ type attribute may be used to distinguish between them. An Extension may be used instead of or along with an Expression and Parameters list. Expressions may populate Responses that are set to @readOnly = \"true\" to ensure that all responses are calculated and not latered by the user. Alternatively, the user may change a value created by (or instead of) the Expression.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Parameter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ParameterItemType"
          }
        }
      }
    },
    "CallFuncType": {
      "description": "Function or web service that returns a string value.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Function": {
          "$ref": "#/definitions/anyURI_Stype"
        },
        "Security": {
          "$ref": "#/definitions/RichTextType"
        },
        "ParameterRef": {
          "items": {
            "$ref": "#/definitions/ParameterItemType"
          }
        },
        "ParameterValue": {
          "items": {
            "$ref": "#/definitions/ParameterValueType"
          }
        }
      },
      "required": [
        "Function"
      ]
    },
    "toggleType": {
      "type": "string",
      "enum": [
        "true",
        "false",
        "toggle"
      ]
    },
    "ChildElementsGroup": {
      "type": "object"
    },
    "DataElementType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Section": {
          "items": {
            "$ref": "#/definitions/SectionItemType"
          }
        },
        "Question": {
          "items": {
            "$ref": "#/definitions/QuestionItemType"
          }
        },
        "DisplayedItem": {
          "items": {
            "$ref": "#/definitions/DisplayedType"
          }
        },
        "ButtonAction": {
          "items": {
            "$ref": "#/definitions/ButtonItemType"
          }
        },
        "InjectForm": {
          "items": {
            "$ref": "#/definitions/InjectFormType"
          }
        },
        "prevVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "basedOnURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "filename": {
          "description": "Filename to use when the current DE XML is saved as a file.",
          "type": "string"
        },
        "title": {
          "description": "Human readable title for display when choosing DEs",
          "type": "string"
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "FormDesignType": {
      "description": "Start here. This is the top level of the SDCFormDesign object model. It represents the definition for the information content of a single data-entry form.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "BeforeLoadForm": {
          "$ref": "#/definitions/EventType"
        },
        "BeforeLoadData": {
          "$ref": "#/definitions/EventType"
        },
        "BeforeShowForm": {
          "$ref": "#/definitions/EventType"
        },
        "BeforeDataSubmit": {
          "$ref": "#/definitions/EventType"
        },
        "BeforeCloseForm": {
          "$ref": "#/definitions/EventType"
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "Header": {
          "$ref": "#/definitions/SectionItemType"
        },
        "Body": {
          "$ref": "#/definitions/SectionItemType"
        },
        "Footer": {
          "$ref": "#/definitions/SectionItemType"
        },
        "Rules": {
          "$ref": "#/definitions/RulesType"
        },
        "formTitle": {
          "description": "NEW: human readable title for display when choosing forms. Added 4/27/16",
          "type": "string"
        },
        "filename": {
          "description": "NEW: filename to use when the current FormDesign instance is saved as a file.   For forms containing responses, the filename may include the formInstanceVersionURI,   but the naming convention may be use-case-specific.",
          "type": "string"
        },
        "basedOnURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "lineage": {
          "description": "NEW: A text identifier that is used to group multiple versions of a single form. The lineage is constant for all versions of a single kind of form.   When appended to @baseURI, it can be used to retrieve all versions of one particular form.",
          "type": "string"
        },
        "version": {
          "description": "NEW: @version contains the version text for the current form. It is designed to be used in conjuction with @baseURI and @lineage.",
          "type": "string"
        },
        "fullURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "prevVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "formInstanceURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "formInstanceVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "formPreviousInstanceVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "responseTypeEnum": {
          "description": "Allows the form filler to specify whether the current response is the initial response, or records the type of change made since the initial response was reported.",
          "type": "string",
          "enum": [
            "initial",
            "correction",
            "update",
            "addition",
            "deletion",
            "multiple_changes"
          ]
        },
        "responseStatusEnum": {
          "description": "Expresses the finality of the response, e.g., draft, pending, tentative, final and retracted.",
          "type": "string",
          "enum": [
            "draft",
            "pending",
            "preliminary",
            "final",
            "retracted"
          ]
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "Body",
        "lineage",
        "version",
        "fullURI",
        "ID"
      ]
    },
    "ChildItemsType": {
      "description": "ChildItems have descendants that are of type DisplayedType. They may include primary items of type SectionType, QuestionType, InjectFormType, DisplayedType and ButtonType, in any order. The ChildItem separates new child primary items from elements and attributes that are sub-parts of the parent primary item.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Section": {
          "items": {
            "$ref": "#/definitions/SectionItemType"
          }
        },
        "Question": {
          "items": {
            "$ref": "#/definitions/QuestionItemType"
          }
        },
        "DisplayedItem": {
          "items": {
            "$ref": "#/definitions/DisplayedType"
          }
        },
        "ButtonAction": {
          "items": {
            "$ref": "#/definitions/ButtonItemType"
          }
        },
        "InjectForm": {
          "items": {
            "$ref": "#/definitions/InjectFormType"
          }
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "InjectFormType": {
      "description": "CHANGED: This type represents a form or portion of a form that is imported into the current form at a specific location. It allows the composition of forms from other forms or parts of other forms.  In practice, using an injected section will requiresome or all of the injected FormDesignXML to be injected under this the InjectForm element. For that reason, the schema supports those elements to appear inline. However, in a \"raw\" form (not yet filled out), the FormDesign element would generally be empty; only the top-level InjectFormType attributes would be used to point to the parts to be later injected.  Form parts to be injected are specified by packageID, not FormID. This allows an injected form to be assocaited with helper files, or to return previosuly completed form parts containing responses.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Section": {
          "items": {
            "$ref": "#/definitions/SectionItemType"
          }
        },
        "Question": {
          "items": {
            "$ref": "#/definitions/QuestionItemType"
          }
        },
        "FormDesign": {
          "items": {
            "$ref": "#/definitions/FormDesignType"
          }
        },
        "packageID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "packageBaseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "rootItemID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "injectionID": {
          "description": "Unique ID (GUID) to distinguish multiple instances of the same injected node.",
          "type": "string"
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "LookupEndPointType": {
      "description": "LookupEndPointType represents list items that are derived from a web service call of some type, instead of an explicit set of ListItem nodes specified in the FormDesign XML. The endpoint must return a list separated into individual list items by the @colTextDelimiter value specified in the parent ListFieldType.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Function": {
          "$ref": "#/definitions/anyURI_Stype"
        },
        "Security": {
          "$ref": "#/definitions/RichTextType"
        },
        "ParameterRef": {
          "items": {
            "$ref": "#/definitions/ParameterItemType"
          }
        },
        "ParameterValue": {
          "items": {
            "$ref": "#/definitions/ParameterValueType"
          }
        },
        "ResponseValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "includesHeaderRow": {
          "type": "boolean"
        },
        "dataTypeListAll": {
          "type": [
            "string",
            "number",
            "boolean"
          ]
        },
        "returnList": {
          "description": "True if the return type is a kind of list.",
          "type": "boolean"
        },
        "objectTypeName": {
          "description": "If the function returns a custom object, even if serialized e.g., as XML of JSON, provide the object type name here.",
          "type": "string"
        },
        "objectFormat": {
          "description": "The serialization format of the returned data, e.g., XML, JSON, binary, etc., or a more specific type.",
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "Function"
      ]
    },
    "ListItemType": {
      "description": "ListItem elements represent answer choices that may appear under a Question.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "BlobContent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlobType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "CodedValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "OnEnter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnExit": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "ActivateIf": {
          "$ref": "#/definitions/GuardType"
        },
        "DeActivateIf": {
          "$ref": "#/definitions/GuardType"
        },
        "ListItemResponseField": {
          "$ref": "#/definitions/ListItemResponseFieldType"
        },
        "OnSelect": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnDeselect": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "SelectIf": {
          "$ref": "#/definitions/GuardType"
        },
        "DeselectIf": {
          "$ref": "#/definitions/GuardType"
        },
        "ChildItems": {
          "items": {
            "$ref": "#/definitions/ChildItemsType"
          }
        },
        "selected": {
          "description": "Represents the default value of the ListItem in the FormDesign template, or the user's response in selecting one or more ListItems. If @multiSelect='false' on ListField then only one item may be selected.",
          "type": "boolean"
        },
        "selectionDisablesChildren": {
          "description": "If set to true, then selecting this ListItem must deactivate all descendant parts of the form, and ignore any user-entered values in the deactivated part. Deselecting the ListItem should reactivate the descendant items in their state at the time the items were deactivated.  If items are disabled, then any data stored in the disabled questions should be removed.",
          "type": "boolean"
        },
        "selectionActivatesItems": {
          "description": "NEW Selecting the current ListItem will enable the named items in this attribute's content.  Prefixing any named with a hyphen (-) will reverse the above behaviour (i.e., the named items will be disabled).  Unselecting the ListItem will reverse this behaviour. Prefixing the name with a tilde (~) will supress this reversal behavior.",
          "type": "string"
        },
        "selectionSelectsListItems": {
          "description": "NEW Selecting the current ListItem will select the named ListItems in this attribute's content.  Prefixing any named with a hyphen (-) will reverse the above behaviour.  Unselecting the ListItem will reverse this behaviour. Prefixing the name with a tilde (~) will suppress this reversal behavior.",
          "type": "string"
        },
        "selectionDeselectsSiblings": {
          "description": "If the ancestor ListField has @multiselect = 'true', then selecting this ListItem should de-select all other ListItem (sibling) nodes except the current one.",
          "type": "boolean"
        },
        "omitWhenSelected": {
          "description": "NEW:   If @omitWhenSelected is set to true, then the question and its response(s) should not be present in a typical report derived from this template. This attribute is usually set to true when the answer choice is used to control form behavior (e.g., skip logic), or when the question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed or could not be assessed. If @omitWhenSelectedset is false (default) then the question and its response(s) should appear in the report. Added 11/29/15 to replace @reportAction",
          "type": "boolean"
        },
        "repeat": {
          "description": "For repeating questions and sections, @repeat represents the repeat ordinality, starting with 1.",
          "type": "integer"
        },
        "instanceGUID": {
          "description": "A globally unique string assigned to a repeating Question or Section, Injected Form, or any selected answer ListItem. This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among sections or questions, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "parentGUID": {
          "description": "A globally unique string assigned from a Section, Question, ListItem or InjectedForm to the ID of its parent node (S, Q, LI or IF). This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among the above objects, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "associatedValue": {
          "description": "A typed value (e.g., an integer) that is uniquely associated with a ListItem. An example is the integer 10 for a ListItem with title that reads \"10 o'clock\". Typically these values are set to be used in calculations or other algorithms. In general, they can be treated something like a user-entered response on a the ListItemResponseField of a selected ListItem.  This field should not be used for terminologies or local codes. The CodedValue type should be used for these kinds of metadata. This field should also not be used other properties such as translations, usage, etc.  The data type shoudl be specified in @AssociatedValueType",
          "type": "string"
        },
        "associatedValueType": {
          "$ref": "#/definitions/DataTypeAll_StypeEnum"
        },
        "title": {
          "description": "The primary text to show on the form. Also known as \"prompt\" or \"label\" or \"visibleText\" or \"caption\"",
          "type": "string"
        },
        "enabled": {
          "description": "Determines whether the user can interact with the displayed item when the form is first displayed.",
          "type": "boolean"
        },
        "visible": {
          "description": "Determines whether the item should be visible on a computer screen when the form is first displayed.",
          "type": "boolean"
        },
        "mustImplement": {
          "description": "If this attribute is set to \"true\" (the default), then the form implementation must make this item available for use on the form. If this attribute is set to \"false\" on a parent or ancestor item, then all child/descendant items inherit this \"false\" setting, even if they have this attribute set to \"true.\" In other words, the child/descendent items do not need to be implemented if any parent/ancestor item has this attribute set to false.",
          "type": "boolean"
        },
        "showInReport": {
          "description": "CHANGED to T/F/Optional  If @showInReport on a Question is false, then the Question and its ListItems (if any) should not be present in a typical report derived from this template. If this attribute appears on a ListItem, then the entire question and all ListItems should be omitted from the report. If this attribute appears on a Section, then the entire Section and all Section contents (descendents) should be omitted from the report. If @showInReport appears on a DisplayedItem, then the DisplayedItem (and all sub-items) should be omitted from the report.  This attribute is usually set to false when a Question is used to control form behavior (e.g., skip logic), or when the Question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed.",
          "type": "string",
          "enum": [
            "True",
            "False",
            "Optional"
          ]
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "ListItemBaseType": {
      "description": "This base element is the foundation for ListItems, but does not include the MainItems sub-group under each ListItem.",
      "type": "object",
      "properties": {
        "selected": {
          "description": "Represents the default value of the ListItem in the FormDesign template, or the user's response in selecting one or more ListItems. If @multiSelect='false' on ListField then only one item may be selected.",
          "type": "boolean"
        },
        "selectionDisablesChildren": {
          "description": "If set to true, then selecting this ListItem must deactivate all descendant parts of the form, and ignore any user-entered values in the deactivated part. Deselecting the ListItem should reactivate the descendant items in their state at the time the items were deactivated.  If items are disabled, then any data stored in the disabled questions should be removed.",
          "type": "boolean"
        },
        "selectionActivatesItems": {
          "description": "NEW Selecting the current ListItem will enable the named items in this attribute's content.  Prefixing any named with a hyphen (-) will reverse the above behaviour (i.e., the named items will be disabled).  Unselecting the ListItem will reverse this behaviour. Prefixing the name with a tilde (~) will supress this reversal behavior.",
          "type": "string"
        },
        "selectionSelectsListItems": {
          "description": "NEW Selecting the current ListItem will select the named ListItems in this attribute's content.  Prefixing any named with a hyphen (-) will reverse the above behaviour.  Unselecting the ListItem will reverse this behaviour. Prefixing the name with a tilde (~) will suppress this reversal behavior.",
          "type": "string"
        },
        "selectionDeselectsSiblings": {
          "description": "If the ancestor ListField has @multiselect = 'true', then selecting this ListItem should de-select all other ListItem (sibling) nodes except the current one.",
          "type": "boolean"
        },
        "omitWhenSelected": {
          "description": "NEW:   If @omitWhenSelected is set to true, then the question and its response(s) should not be present in a typical report derived from this template. This attribute is usually set to true when the answer choice is used to control form behavior (e.g., skip logic), or when the question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed or could not be assessed. If @omitWhenSelectedset is false (default) then the question and its response(s) should appear in the report. Added 11/29/15 to replace @reportAction",
          "type": "boolean"
        },
        "repeat": {
          "description": "For repeating questions and sections, @repeat represents the repeat ordinality, starting with 1.",
          "type": "integer"
        },
        "instanceGUID": {
          "description": "A globally unique string assigned to a repeating Question or Section, Injected Form, or any selected answer ListItem. This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among sections or questions, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "parentGUID": {
          "description": "A globally unique string assigned from a Section, Question, ListItem or InjectedForm to the ID of its parent node (S, Q, LI or IF). This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among the above objects, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "associatedValue": {
          "description": "A typed value (e.g., an integer) that is uniquely associated with a ListItem. An example is the integer 10 for a ListItem with title that reads \"10 o'clock\". Typically these values are set to be used in calculations or other algorithms. In general, they can be treated something like a user-entered response on a the ListItemResponseField of a selected ListItem.  This field should not be used for terminologies or local codes. The CodedValue type should be used for these kinds of metadata. This field should also not be used other properties such as translations, usage, etc.  The data type shoudl be specified in @AssociatedValueType",
          "type": "string"
        },
        "associatedValueType": {
          "$ref": "#/definitions/DataTypeAll_StypeEnum"
        },
        "title": {
          "description": "The primary text to show on the form. Also known as \"prompt\" or \"label\" or \"visibleText\" or \"caption\"",
          "type": "string"
        },
        "enabled": {
          "description": "Determines whether the user can interact with the displayed item when the form is first displayed.",
          "type": "boolean"
        },
        "visible": {
          "description": "Determines whether the item should be visible on a computer screen when the form is first displayed.",
          "type": "boolean"
        },
        "mustImplement": {
          "description": "If this attribute is set to \"true\" (the default), then the form implementation must make this item available for use on the form. If this attribute is set to \"false\" on a parent or ancestor item, then all child/descendant items inherit this \"false\" setting, even if they have this attribute set to \"true.\" In other words, the child/descendent items do not need to be implemented if any parent/ancestor item has this attribute set to false.",
          "type": "boolean"
        },
        "showInReport": {
          "description": "CHANGED to T/F/Optional  If @showInReport on a Question is false, then the Question and its ListItems (if any) should not be present in a typical report derived from this template. If this attribute appears on a ListItem, then the entire question and all ListItems should be omitted from the report. If this attribute appears on a Section, then the entire Section and all Section contents (descendents) should be omitted from the report. If @showInReport appears on a DisplayedItem, then the DisplayedItem (and all sub-items) should be omitted from the report.  This attribute is usually set to false when a Question is used to control form behavior (e.g., skip logic), or when the Question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed.",
          "type": "string",
          "enum": [
            "True",
            "False",
            "Optional"
          ]
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "ListType": {
      "description": "This type represents a list of specified answer choices.  CHANGED 9/20/2016: Fix for serialization error which aggregated all DisplayedItems at the top of the ListItems.  A Schematron (or similar validation tool) will be required to ensure that at least 2 ListItems are present for single-select questions, and one ListItem for multi-select questions.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "DisplayedItem": {
          "items": {
            "$ref": "#/definitions/DisplayedType"
          }
        },
        "ListItem": {
          "items": {
            "$ref": "#/definitions/ListItemType"
          }
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "ListFieldType": {
      "description": "ListField is a grouper for list-like answer choices, which may be derived from either a set of answer choice lists (a List composed of ListItems) or or a list obtained from a LookupEndpoint URI.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "ListHeaderText": {
          "$ref": "#/definitions/RichTextType"
        },
        "DefaultCodeSystem": {
          "$ref": "#/definitions/CodeSystemType"
        },
        "List": {
          "items": {
            "$ref": "#/definitions/ListType"
          }
        },
        "LookupEndPoint": {
          "items": {
            "$ref": "#/definitions/LookupEndPointType"
          }
        },
        "IllegalListItemPairings": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleSelectionTestType"
          }
        },
        "IllegalCoSelectedListItems": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleSingleSelectionSetsType"
          }
        },
        "AfterChange": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "colTextDelimiter": {
          "description": "Character in the DisplayText that separates the columns and rows in a single or multi-column list.",
          "type": "string",
          "minLength": 1,
          "maxLength": 1
        },
        "numCols": {
          "description": "Number of columns in the list",
          "type": "integer"
        },
        "storedCol": {
          "description": "Determines which column of the list is stored in a database. This list is one-based.",
          "type": "integer"
        },
        "minSelections": {
          "description": "Minimum number of answer choices (list items) that must be selected by the user. Default value is 1.  NEW: changed minimum value to 1. Removed: If set to 0, then this question need not be answered by the user.",
          "type": "integer",
          "minimum": 1.0
        },
        "maxSelections": {
          "description": "Maximum number of answer choices (list items) that can be selected by the user. Must be greater than or equal to minSelections, and no larger than the total number of list items.   A value of 0 indicates no limit to the number of selected list items (answers). This effectively means that the question is multi-select. (Abbreviated as QM)  A value of 1 (the default) indicates that the question list is single-select. (Abbreviated as QS)",
          "type": "integer"
        },
        "ordered": {
          "description": "If false, then the form implementation may change the order of items in the list.",
          "type": "boolean"
        },
        "defaultListItemDataType": {
          "$ref": "#/definitions/DataTypeAll_StypeEnum"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "ResponseFieldType": {
      "description": "This type is a template for a data entry field that accepts entries (responses or answers) of any data type, including text, numbers, dates, and Base 64 - encoded blobs (images, sounds, video, other binary formats, etc.). This type cannot contain ListItems, but it may be a child of a Question or a ListItem.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Response": {
          "$ref": "#/definitions/DataTypes_DEType"
        },
        "CallSetValue": {
          "items": {
            "$ref": "#/definitions/CallFuncType"
          }
        },
        "SetValue": {
          "items": {
            "$ref": "#/definitions/ScriptCodeAnyType"
          }
        },
        "TextAfterResponse": {
          "$ref": "#/definitions/RichTextType"
        },
        "ResponseUnits": {
          "$ref": "#/definitions/UnitsType"
        },
        "AfterChange": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "Response"
      ]
    },
    "ListItemResponseFieldType": {
      "description": "This type represents a place to store a fill-in response associated directly with a selected ListItem. The response may be optional or required.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Response": {
          "$ref": "#/definitions/DataTypes_DEType"
        },
        "CallSetValue": {
          "items": {
            "$ref": "#/definitions/CallFuncType"
          }
        },
        "SetValue": {
          "items": {
            "$ref": "#/definitions/ScriptCodeAnyType"
          }
        },
        "TextAfterResponse": {
          "$ref": "#/definitions/RichTextType"
        },
        "ResponseUnits": {
          "$ref": "#/definitions/UnitsType"
        },
        "AfterChange": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "responseRequired": {
          "description": "If @responseRequired is set to true, then the appropriate text or Blob must be entered in the data-entry field associated with this list item.",
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "Response"
      ]
    },
    "ButtonItemType": {
      "description": "The ButtonAction type represents a visual area for a user to click, and the click triggers a piece of \"Action\" code to run inside the form. The ButtonAction object may be represented with a visible button object, or some other type of visual paradigm. Other types of actions (e.g. key presses in a text field) may be handled with the form framework's event model.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "BlobContent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlobType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "CodedValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "OnEnter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnExit": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "ActivateIf": {
          "$ref": "#/definitions/GuardType"
        },
        "DeActivateIf": {
          "$ref": "#/definitions/GuardType"
        },
        "OnClick": {
          "$ref": "#/definitions/EventType"
        },
        "title": {
          "description": "The primary text to show on the form. Also known as \"prompt\" or \"label\" or \"visibleText\" or \"caption\"",
          "type": "string"
        },
        "enabled": {
          "description": "Determines whether the user can interact with the displayed item when the form is first displayed.",
          "type": "boolean"
        },
        "visible": {
          "description": "Determines whether the item should be visible on a computer screen when the form is first displayed.",
          "type": "boolean"
        },
        "mustImplement": {
          "description": "If this attribute is set to \"true\" (the default), then the form implementation must make this item available for use on the form. If this attribute is set to \"false\" on a parent or ancestor item, then all child/descendant items inherit this \"false\" setting, even if they have this attribute set to \"true.\" In other words, the child/descendent items do not need to be implemented if any parent/ancestor item has this attribute set to false.",
          "type": "boolean"
        },
        "showInReport": {
          "description": "CHANGED to T/F/Optional  If @showInReport on a Question is false, then the Question and its ListItems (if any) should not be present in a typical report derived from this template. If this attribute appears on a ListItem, then the entire question and all ListItems should be omitted from the report. If this attribute appears on a Section, then the entire Section and all Section contents (descendents) should be omitted from the report. If @showInReport appears on a DisplayedItem, then the DisplayedItem (and all sub-items) should be omitted from the report.  This attribute is usually set to false when a Question is used to control form behavior (e.g., skip logic), or when the Question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed.",
          "type": "string",
          "enum": [
            "True",
            "False",
            "Optional"
          ]
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "SectionItemType": {
      "description": "The Section is a grouper for all other types of objects. It may have a distinctive visual display (e.g. a box containing other displayed objects), and it may be used to treat Section descendants as a unit for special handling, such as hiding and showing.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "BlobContent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlobType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "CodedValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "OnEnter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnExit": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "ActivateIf": {
          "$ref": "#/definitions/GuardType"
        },
        "DeActivateIf": {
          "$ref": "#/definitions/GuardType"
        },
        "ChildItems": {
          "items": {
            "$ref": "#/definitions/ChildItemsType"
          }
        },
        "ordered": {
          "description": "If false, then the form implementation may change the order of items in the section.",
          "type": "boolean"
        },
        "responseTypeEnum": {
          "description": "Allows the form filler to specify whether the current response is the initial response, or records the type of change made since the initial response was reported.",
          "type": "string",
          "enum": [
            "initial",
            "correction",
            "update",
            "addition",
            "deletion",
            "multiple_changes"
          ]
        },
        "responseStatusEnum": {
          "description": "Expresses the finality of the response, e.g., draft, pending, tentative, final and retracted.",
          "type": "string",
          "enum": [
            "draft",
            "pending",
            "preliminary",
            "final",
            "retracted"
          ]
        },
        "minCard": {
          "description": "@minCard is the minimum number of repetitions allowed for a section or question. The default value is 1, indicating that the user must answer any question(s) that has this attribute set. If @minCard is set to 0, then the item and all descendent questions are optional to answer.",
          "type": "integer"
        },
        "maxCard": {
          "description": "@maxCard is the maximum number of repetitions allowed for a section or question. The default value is 1, indicating that the section or question cannot be repeated on the data entry form. A value of 0 indicates that the number of repeats is unlimited. If @maxCard is not 0, then Must be greater than or equal to minCard.",
          "type": "integer"
        },
        "repeat": {
          "description": "For repeating questions and sections, @repeat represents the repeat ordinality, starting with 1.",
          "type": "integer"
        },
        "instanceGUID": {
          "description": "A globally unique string assigned to a repeating Question or Section, Injected Form, or any selected answer ListItem. This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among sections or questions, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "parentGUID": {
          "description": "A globally unique string assigned from a Section, Question, ListItem or InjectedForm to the ID of its parent node (S, Q, LI or IF). This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among the above objects, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "title": {
          "description": "The primary text to show on the form. Also known as \"prompt\" or \"label\" or \"visibleText\" or \"caption\"",
          "type": "string"
        },
        "enabled": {
          "description": "Determines whether the user can interact with the displayed item when the form is first displayed.",
          "type": "boolean"
        },
        "visible": {
          "description": "Determines whether the item should be visible on a computer screen when the form is first displayed.",
          "type": "boolean"
        },
        "mustImplement": {
          "description": "If this attribute is set to \"true\" (the default), then the form implementation must make this item available for use on the form. If this attribute is set to \"false\" on a parent or ancestor item, then all child/descendant items inherit this \"false\" setting, even if they have this attribute set to \"true.\" In other words, the child/descendent items do not need to be implemented if any parent/ancestor item has this attribute set to false.",
          "type": "boolean"
        },
        "showInReport": {
          "description": "CHANGED to T/F/Optional  If @showInReport on a Question is false, then the Question and its ListItems (if any) should not be present in a typical report derived from this template. If this attribute appears on a ListItem, then the entire question and all ListItems should be omitted from the report. If this attribute appears on a Section, then the entire Section and all Section contents (descendents) should be omitted from the report. If @showInReport appears on a DisplayedItem, then the DisplayedItem (and all sub-items) should be omitted from the report.  This attribute is usually set to false when a Question is used to control form behavior (e.g., skip logic), or when the Question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed.",
          "type": "string",
          "enum": [
            "True",
            "False",
            "Optional"
          ]
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "SectionBaseType": {
      "description": "This base item is the same as the SectionItemType, except it lacks the recursion created by the inclusion of MainItems sub-group.",
      "type": "object",
      "properties": {
        "ordered": {
          "description": "If false, then the form implementation may change the order of items in the section.",
          "type": "boolean"
        },
        "responseTypeEnum": {
          "description": "Allows the form filler to specify whether the current response is the initial response, or records the type of change made since the initial response was reported.",
          "type": "string",
          "enum": [
            "initial",
            "correction",
            "update",
            "addition",
            "deletion",
            "multiple_changes"
          ]
        },
        "responseStatusEnum": {
          "description": "Expresses the finality of the response, e.g., draft, pending, tentative, final and retracted.",
          "type": "string",
          "enum": [
            "draft",
            "pending",
            "preliminary",
            "final",
            "retracted"
          ]
        },
        "minCard": {
          "description": "@minCard is the minimum number of repetitions allowed for a section or question. The default value is 1, indicating that the user must answer any question(s) that has this attribute set. If @minCard is set to 0, then the item and all descendent questions are optional to answer.",
          "type": "integer"
        },
        "maxCard": {
          "description": "@maxCard is the maximum number of repetitions allowed for a section or question. The default value is 1, indicating that the section or question cannot be repeated on the data entry form. A value of 0 indicates that the number of repeats is unlimited. If @maxCard is not 0, then Must be greater than or equal to minCard.",
          "type": "integer"
        },
        "repeat": {
          "description": "For repeating questions and sections, @repeat represents the repeat ordinality, starting with 1.",
          "type": "integer"
        },
        "instanceGUID": {
          "description": "A globally unique string assigned to a repeating Question or Section, Injected Form, or any selected answer ListItem. This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among sections or questions, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "parentGUID": {
          "description": "A globally unique string assigned from a Section, Question, ListItem or InjectedForm to the ID of its parent node (S, Q, LI or IF). This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among the above objects, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "title": {
          "description": "The primary text to show on the form. Also known as \"prompt\" or \"label\" or \"visibleText\" or \"caption\"",
          "type": "string"
        },
        "enabled": {
          "description": "Determines whether the user can interact with the displayed item when the form is first displayed.",
          "type": "boolean"
        },
        "visible": {
          "description": "Determines whether the item should be visible on a computer screen when the form is first displayed.",
          "type": "boolean"
        },
        "mustImplement": {
          "description": "If this attribute is set to \"true\" (the default), then the form implementation must make this item available for use on the form. If this attribute is set to \"false\" on a parent or ancestor item, then all child/descendant items inherit this \"false\" setting, even if they have this attribute set to \"true.\" In other words, the child/descendent items do not need to be implemented if any parent/ancestor item has this attribute set to false.",
          "type": "boolean"
        },
        "showInReport": {
          "description": "CHANGED to T/F/Optional  If @showInReport on a Question is false, then the Question and its ListItems (if any) should not be present in a typical report derived from this template. If this attribute appears on a ListItem, then the entire question and all ListItems should be omitted from the report. If this attribute appears on a Section, then the entire Section and all Section contents (descendents) should be omitted from the report. If @showInReport appears on a DisplayedItem, then the DisplayedItem (and all sub-items) should be omitted from the report.  This attribute is usually set to false when a Question is used to control form behavior (e.g., skip logic), or when the Question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed.",
          "type": "string",
          "enum": [
            "True",
            "False",
            "Optional"
          ]
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "QuestionItemType": {
      "description": "Represents questions. Parent items may be Section, Question, and ListItem.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "BlobContent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlobType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "CodedValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "OnEnter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnExit": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "ActivateIf": {
          "$ref": "#/definitions/GuardType"
        },
        "DeActivateIf": {
          "$ref": "#/definitions/GuardType"
        },
        "ResponseField": {
          "items": {
            "$ref": "#/definitions/ResponseFieldType"
          }
        },
        "ListField": {
          "items": {
            "$ref": "#/definitions/ListFieldType"
          }
        },
        "ChildItems": {
          "items": {
            "$ref": "#/definitions/ChildItemsType"
          }
        },
        "readOnly": {
          "description": "If @readOnly is set to true, the this field may not be edited by the user, and any default values set by template should be considered part of the stored data set responses, and transmitted by the SubmitForm transaction.",
          "type": "boolean"
        },
        "responseTypeEnum": {
          "description": "Allows the form filler to specify whether the current response is the initial response, or records the type of change made since the initial response was reported.",
          "type": "string",
          "enum": [
            "initial",
            "correction",
            "update",
            "addition",
            "deletion",
            "multiple_changes"
          ]
        },
        "responseStatusEnum": {
          "description": "Expresses the finality of the response, e.g., draft, pending, tentative, final and retracted.",
          "type": "string",
          "enum": [
            "draft",
            "pending",
            "preliminary",
            "final",
            "retracted"
          ]
        },
        "minCard": {
          "description": "@minCard is the minimum number of repetitions allowed for a section or question. The default value is 1, indicating that the user must answer any question(s) that has this attribute set. If @minCard is set to 0, then the item and all descendent questions are optional to answer.",
          "type": "integer"
        },
        "maxCard": {
          "description": "@maxCard is the maximum number of repetitions allowed for a section or question. The default value is 1, indicating that the section or question cannot be repeated on the data entry form. A value of 0 indicates that the number of repeats is unlimited. If @maxCard is not 0, then Must be greater than or equal to minCard.",
          "type": "integer"
        },
        "repeat": {
          "description": "For repeating questions and sections, @repeat represents the repeat ordinality, starting with 1.",
          "type": "integer"
        },
        "instanceGUID": {
          "description": "A globally unique string assigned to a repeating Question or Section, Injected Form, or any selected answer ListItem. This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among sections or questions, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "parentGUID": {
          "description": "A globally unique string assigned from a Section, Question, ListItem or InjectedForm to the ID of its parent node (S, Q, LI or IF). This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among the above objects, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "title": {
          "description": "The primary text to show on the form. Also known as \"prompt\" or \"label\" or \"visibleText\" or \"caption\"",
          "type": "string"
        },
        "enabled": {
          "description": "Determines whether the user can interact with the displayed item when the form is first displayed.",
          "type": "boolean"
        },
        "visible": {
          "description": "Determines whether the item should be visible on a computer screen when the form is first displayed.",
          "type": "boolean"
        },
        "mustImplement": {
          "description": "If this attribute is set to \"true\" (the default), then the form implementation must make this item available for use on the form. If this attribute is set to \"false\" on a parent or ancestor item, then all child/descendant items inherit this \"false\" setting, even if they have this attribute set to \"true.\" In other words, the child/descendent items do not need to be implemented if any parent/ancestor item has this attribute set to false.",
          "type": "boolean"
        },
        "showInReport": {
          "description": "CHANGED to T/F/Optional  If @showInReport on a Question is false, then the Question and its ListItems (if any) should not be present in a typical report derived from this template. If this attribute appears on a ListItem, then the entire question and all ListItems should be omitted from the report. If this attribute appears on a Section, then the entire Section and all Section contents (descendents) should be omitted from the report. If @showInReport appears on a DisplayedItem, then the DisplayedItem (and all sub-items) should be omitted from the report.  This attribute is usually set to false when a Question is used to control form behavior (e.g., skip logic), or when the Question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed.",
          "type": "string",
          "enum": [
            "True",
            "False",
            "Optional"
          ]
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "QuestionItemBaseType": {
      "description": "Represents questions. Parent items may be Section, Question, and ListItem.",
      "type": "object",
      "properties": {
        "readOnly": {
          "description": "If @readOnly is set to true, the this field may not be edited by the user, and any default values set by template should be considered part of the stored data set responses, and transmitted by the SubmitForm transaction.",
          "type": "boolean"
        },
        "responseTypeEnum": {
          "description": "Allows the form filler to specify whether the current response is the initial response, or records the type of change made since the initial response was reported.",
          "type": "string",
          "enum": [
            "initial",
            "correction",
            "update",
            "addition",
            "deletion",
            "multiple_changes"
          ]
        },
        "responseStatusEnum": {
          "description": "Expresses the finality of the response, e.g., draft, pending, tentative, final and retracted.",
          "type": "string",
          "enum": [
            "draft",
            "pending",
            "preliminary",
            "final",
            "retracted"
          ]
        },
        "minCard": {
          "description": "@minCard is the minimum number of repetitions allowed for a section or question. The default value is 1, indicating that the user must answer any question(s) that has this attribute set. If @minCard is set to 0, then the item and all descendent questions are optional to answer.",
          "type": "integer"
        },
        "maxCard": {
          "description": "@maxCard is the maximum number of repetitions allowed for a section or question. The default value is 1, indicating that the section or question cannot be repeated on the data entry form. A value of 0 indicates that the number of repeats is unlimited. If @maxCard is not 0, then Must be greater than or equal to minCard.",
          "type": "integer"
        },
        "repeat": {
          "description": "For repeating questions and sections, @repeat represents the repeat ordinality, starting with 1.",
          "type": "integer"
        },
        "instanceGUID": {
          "description": "A globally unique string assigned to a repeating Question or Section, Injected Form, or any selected answer ListItem. This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among sections or questions, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "parentGUID": {
          "description": "A globally unique string assigned from a Section, Question, ListItem or InjectedForm to the ID of its parent node (S, Q, LI or IF). This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among the above objects, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "title": {
          "description": "The primary text to show on the form. Also known as \"prompt\" or \"label\" or \"visibleText\" or \"caption\"",
          "type": "string"
        },
        "enabled": {
          "description": "Determines whether the user can interact with the displayed item when the form is first displayed.",
          "type": "boolean"
        },
        "visible": {
          "description": "Determines whether the item should be visible on a computer screen when the form is first displayed.",
          "type": "boolean"
        },
        "mustImplement": {
          "description": "If this attribute is set to \"true\" (the default), then the form implementation must make this item available for use on the form. If this attribute is set to \"false\" on a parent or ancestor item, then all child/descendant items inherit this \"false\" setting, even if they have this attribute set to \"true.\" In other words, the child/descendent items do not need to be implemented if any parent/ancestor item has this attribute set to false.",
          "type": "boolean"
        },
        "showInReport": {
          "description": "CHANGED to T/F/Optional  If @showInReport on a Question is false, then the Question and its ListItems (if any) should not be present in a typical report derived from this template. If this attribute appears on a ListItem, then the entire question and all ListItems should be omitted from the report. If this attribute appears on a Section, then the entire Section and all Section contents (descendents) should be omitted from the report. If @showInReport appears on a DisplayedItem, then the DisplayedItem (and all sub-items) should be omitted from the report.  This attribute is usually set to false when a Question is used to control form behavior (e.g., skip logic), or when the Question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed.",
          "type": "string",
          "enum": [
            "True",
            "False",
            "Optional"
          ]
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "RepeatingType": {
      "description": "This type presents any display objects that may be repeated based upon on the user's interaction with the form objects. Items derived from this type include Sections and Questions.",
      "type": "object",
      "properties": {
        "minCard": {
          "description": "@minCard is the minimum number of repetitions allowed for a section or question. The default value is 1, indicating that the user must answer any question(s) that has this attribute set. If @minCard is set to 0, then the item and all descendent questions are optional to answer.",
          "type": "integer"
        },
        "maxCard": {
          "description": "@maxCard is the maximum number of repetitions allowed for a section or question. The default value is 1, indicating that the section or question cannot be repeated on the data entry form. A value of 0 indicates that the number of repeats is unlimited. If @maxCard is not 0, then Must be greater than or equal to minCard.",
          "type": "integer"
        },
        "repeat": {
          "description": "For repeating questions and sections, @repeat represents the repeat ordinality, starting with 1.",
          "type": "integer"
        },
        "instanceGUID": {
          "description": "A globally unique string assigned to a repeating Question or Section, Injected Form, or any selected answer ListItem. This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among sections or questions, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "parentGUID": {
          "description": "A globally unique string assigned from a Section, Question, ListItem or InjectedForm to the ID of its parent node (S, Q, LI or IF). This attribute's value is assigned at the time that answers are entered into a form, to unambiguously identify a single instance among the above objects, including those that are allowed to repeat and nest deeply.",
          "type": "string"
        },
        "title": {
          "description": "The primary text to show on the form. Also known as \"prompt\" or \"label\" or \"visibleText\" or \"caption\"",
          "type": "string"
        },
        "enabled": {
          "description": "Determines whether the user can interact with the displayed item when the form is first displayed.",
          "type": "boolean"
        },
        "visible": {
          "description": "Determines whether the item should be visible on a computer screen when the form is first displayed.",
          "type": "boolean"
        },
        "mustImplement": {
          "description": "If this attribute is set to \"true\" (the default), then the form implementation must make this item available for use on the form. If this attribute is set to \"false\" on a parent or ancestor item, then all child/descendant items inherit this \"false\" setting, even if they have this attribute set to \"true.\" In other words, the child/descendent items do not need to be implemented if any parent/ancestor item has this attribute set to false.",
          "type": "boolean"
        },
        "showInReport": {
          "description": "CHANGED to T/F/Optional  If @showInReport on a Question is false, then the Question and its ListItems (if any) should not be present in a typical report derived from this template. If this attribute appears on a ListItem, then the entire question and all ListItems should be omitted from the report. If this attribute appears on a Section, then the entire Section and all Section contents (descendents) should be omitted from the report. If @showInReport appears on a DisplayedItem, then the DisplayedItem (and all sub-items) should be omitted from the report.  This attribute is usually set to false when a Question is used to control form behavior (e.g., skip logic), or when the Question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed.",
          "type": "string",
          "enum": [
            "True",
            "False",
            "Optional"
          ]
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "DisplayedType": {
      "description": "This type represents any object that is designed to have a visual presence on a form, e.g., Sections, Questions, ListItems, Notes and Blobs. (Other items not inheriting this type may use an optional styleClass attribute.)",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "BlobContent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlobType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "CodedValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "OnEnter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnExit": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "ActivateIf": {
          "$ref": "#/definitions/GuardType"
        },
        "DeActivateIf": {
          "$ref": "#/definitions/GuardType"
        },
        "title": {
          "description": "The primary text to show on the form. Also known as \"prompt\" or \"label\" or \"visibleText\" or \"caption\"",
          "type": "string"
        },
        "enabled": {
          "description": "Determines whether the user can interact with the displayed item when the form is first displayed.",
          "type": "boolean"
        },
        "visible": {
          "description": "Determines whether the item should be visible on a computer screen when the form is first displayed.",
          "type": "boolean"
        },
        "mustImplement": {
          "description": "If this attribute is set to \"true\" (the default), then the form implementation must make this item available for use on the form. If this attribute is set to \"false\" on a parent or ancestor item, then all child/descendant items inherit this \"false\" setting, even if they have this attribute set to \"true.\" In other words, the child/descendent items do not need to be implemented if any parent/ancestor item has this attribute set to false.",
          "type": "boolean"
        },
        "showInReport": {
          "description": "CHANGED to T/F/Optional  If @showInReport on a Question is false, then the Question and its ListItems (if any) should not be present in a typical report derived from this template. If this attribute appears on a ListItem, then the entire question and all ListItems should be omitted from the report. If this attribute appears on a Section, then the entire Section and all Section contents (descendents) should be omitted from the report. If @showInReport appears on a DisplayedItem, then the DisplayedItem (and all sub-items) should be omitted from the report.  This attribute is usually set to false when a Question is used to control form behavior (e.g., skip logic), or when the Question provides unhelpful \"negative\" information about actions that did not occur or were not performed, or things that were not observed.",
          "type": "string",
          "enum": [
            "True",
            "False",
            "Optional"
          ]
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "EventType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Conditions": {
          "items": {
            "$ref": "#/definitions/ConditionsSubActionsType"
          }
        },
        "Actions": {
          "items": {
            "$ref": "#/definitions/ActionsType"
          }
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "OnEventType": {
      "description": "Add a custom event handler to a form item such as a question, section or list item.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Conditions": {
          "items": {
            "$ref": "#/definitions/ConditionsSubActionsType"
          }
        },
        "Actions": {
          "items": {
            "$ref": "#/definitions/ActionsType"
          }
        },
        "eventName": {
          "type": "string"
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "eventName"
      ]
    },
    "ActSetItemAttributeType": {
      "description": "This type is used to act upon the value of common item attributes. If an \"act\" attribute (a type with the \"act\" prefix) has no value assigned, it is ignored. If it has a value, then that attribute on the target item(s) assume(s) that stated value when an attached Boolean condition evaluates to true. The attached condition may be an \"If\" statement or any expression that evaluates to a Boolean value.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "targetNames": {
          "description": "The names of the items affected by property actions",
          "type": "string"
        },
        "actVisible": {
          "type": "boolean"
        },
        "actEnable": {
          "type": "boolean"
        },
        "actMinCard": {
          "description": "Controls requirement to answer the question and the minimum number of repeats.",
          "type": "integer"
        },
        "actMaxCard": {
          "description": "Controls requirement to answer the question",
          "type": "integer"
        },
        "actActivate": {
          "description": "Toggle visible and enabled together. Setting this to false will de-activate all descendents but will not change their enabled or visible properties.",
          "type": "boolean"
        },
        "actSelect": {
          "description": "Toggle selection of a List Item; not applicable to other items.",
          "type": "boolean"
        },
        "actDeleteResponse": {
          "description": "Delete any response in a Response field on a question or ListItem. Not applicable to other item types.",
          "type": "boolean"
        },
        "actReadOnly": {
          "description": "Delete any response in a Response field on a question or ListItem. Not applicable to other item types.",
          "type": "boolean"
        },
        "actType": {
          "description": "Set the @type attribute value",
          "type": "string"
        },
        "actStyleClass": {
          "description": "Set the @styleClass attribute value",
          "type": "string"
        },
        "actSetTitleText": {
          "description": "Set the @title text on an item.",
          "type": "string"
        },
        "actSetBase64HTML": {
          "description": "Set HTML as base-64-encoded binary",
          "type": "string"
        },
        "actSetCode": {
          "type": "string"
        },
        "actSetCodeSystem": {
          "type": "string"
        },
        "actSetVal": {
          "description": "Set a @val attribute. The correct data type must be used if applicable.",
          "type": "string"
        },
        "actSetAssociatedValue": {
          "description": "Set @associatedValue attribute of a ListItem. The correct data type must be used if applicable.",
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "targetNames"
      ]
    },
    "ActSetAttrValueType": {
      "description": "This type is used to act upon the value of common item properties. If an \"act\" property (a property with the \"act\" prefix) has no value assigned, it is ignored. If it has a value, then that property on the target item(s) assume(s) that stated value when an attached Boolean condition evaluates to true. The attached condition may be an \"If\" statement or any expression that evaluates to a Boolean value.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Parameter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ParameterItemType"
          }
        },
        "Target": {
          "$ref": "#/definitions/ItemNameAttributeType"
        },
        "dataTypeListAll": {
          "type": [
            "string",
            "number",
            "boolean"
          ]
        },
        "returnList": {
          "description": "True if the return type is a kind of list.",
          "type": "boolean"
        },
        "objectTypeName": {
          "description": "If the function returns a custom object, even if serialized e.g., as XML of JSON, provide the object type name here.",
          "type": "string"
        },
        "objectFormat": {
          "description": "The serialization format of the returned data, e.g., XML, JSON, binary, etc., or a more specific type.",
          "type": "string"
        },
        "language": {
          "description": "Programming language.",
          "type": "string"
        },
        "code": {
          "description": "Script contents.",
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "Target"
      ]
    },
    "ActSetValueBoolType": {
      "description": "Sets the value of any named attribute. However, it is primarily designed for Response element(s) on a Question or ListItem. The value may be determined by a literal value with a defined data type, the value at another named Response item, an expression written in a specified scripting or programming language, or the value of a named code listed in the same template.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Parameter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ParameterItemType"
          }
        },
        "elementName": {
          "description": "The @name attribute of the referenced element.",
          "type": "string"
        },
        "attributeName": {
          "description": "The name of any attribute on a named element.",
          "type": "string"
        },
        "X_targetNames": {
          "type": "string"
        },
        "language": {
          "description": "Programming language.",
          "type": "string"
        },
        "code": {
          "description": "Script contents.",
          "type": "string"
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "elementName",
        "X_targetNames"
      ]
    },
    "ActShowMessageType": {
      "description": "Display a message to the form user, triggered by activity within the form.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Message": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RichTextType"
          },
          "minItems": 1
        },
        "alertLevel": {
          "type": "string"
        },
        "alertType": {
          "type": "string"
        },
        "messageType": {
          "type": "string"
        },
        "messageCode": {
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "ActShowFormType": {
      "description": "Show an external form to interact with the user.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "formID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "packageID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "displayState": {
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "packageID"
      ]
    },
    "ActSaveResponsesType": {
      "description": "Save the form's responses to the default persistance layer(s). The default format is SDCSubmitForm, but other formats may be defined and used.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "MessageText": {
          "$ref": "#/definitions/RichTextType"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "MessageText"
      ]
    },
    "ActShowReportType": {
      "description": "Show a stored report. The following parameters may be used:  reportID: indicator of a report definition in SDC format.  packageID: retrieve report as a package with ancillary information.  reportInstanceGUID: retreive 1 or more report versions by using a report instance GUID. This may be used in conjunctions with a packageID.  reportInstanceVersionGUID: retrieve a single version of a report representing the state of a report when it was saved. This may be used in conjunctions with a packageID.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "reportID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "packageID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "reportInstanceGuid": {
          "type": "string"
        },
        "reportInstanceVersonGuid": {
          "type": "string"
        },
        "displayState": {
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "ActPreviewReportType": {
      "description": "Show a report preview, based on data in the current form. The following parameter may be used:  reportID: points to a report definition in SDC format.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "reportID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "displayState": {
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "ActSendReportType": {
      "description": "Send a report to an endpoint, via email, fax or web service. The default report will be transmittted in SDCSubmitForm format, but may adopt a custom report type",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Email": {
          "items": {
            "$ref": "#/definitions/EmailAddressType"
          }
        },
        "Fax": {
          "items": {
            "$ref": "#/definitions/PhoneNumberType"
          }
        },
        "WebService": {
          "items": {
            "$ref": "#/definitions/CallFuncType"
          }
        },
        "reportID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "reportInstanceGuid": {
          "type": "string"
        },
        "reportInstanceVersonGuid": {
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "ActSendMessageType": {
      "description": "Send a message to any endpoint. Messages may include alerts of various types. The default datatype for messages is string.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "RichText": {
          "$ref": "#/definitions/HTML_Stype"
        },
        "Email": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EmailAddressType"
            },
            "minItems": 1
          }
        },
        "Fax": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/PhoneNumberType"
            },
            "minItems": 1
          }
        },
        "WebService": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/CallFuncType"
            },
            "minItems": 1
          }
        },
        "messageType": {
          "type": "string"
        },
        "val": {
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "RichText",
        "val"
      ]
    },
    "ActValidateFormType": {
      "description": "Test the data in the form for proper data types, rule integrity, and completeness of required questions.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "ValidationWebService": {
          "$ref": "#/definitions/CallFuncType"
        },
        "validateDataTypes": {
          "type": "boolean"
        },
        "validateRules": {
          "type": "boolean"
        },
        "validateCompleteness": {
          "type": "boolean"
        },
        "validationType": {
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "ActInjectType": {
      "description": "Inject a form or part of a form at the specified location. The injected section may come from the current form.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Section": {
          "items": {
            "$ref": "#/definitions/SectionItemType"
          }
        },
        "Question": {
          "items": {
            "$ref": "#/definitions/QuestionItemType"
          }
        },
        "FormDesign": {
          "items": {
            "$ref": "#/definitions/FormDesignType"
          }
        },
        "targetNames": {
          "description": "The names of the parent items that will have the form (or form section) injected as child node(s).",
          "type": "string"
        },
        "packageID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "packageBaseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "rootItemID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "injectionID": {
          "description": "Unique ID (GUID) to distinguish multiple instances of the same injected node.",
          "type": "string"
        },
        "ID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "ID"
      ]
    },
    "ActAddCodeType": {
      "description": "Add all or part of a coding section to the designated target site.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Code": {
          "$ref": "#/definitions/CodingType"
        },
        "itemName": {
          "description": "The @name attribute of the referenced element.",
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "Code",
        "itemName"
      ]
    },
    "ActActionType": {
      "description": "Add a custom action, not defined in the basic SDC Schemas.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Parameter": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/ParameterItemType"
            }
          }
        },
        "ParameterValue": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/ParameterValueType"
            }
          }
        },
        "action": {
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "action"
      ]
    },
    "ActionsType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Action": {
          "items": {
            "$ref": "#/definitions/ActActionType"
          }
        },
        "SetProperty": {
          "items": {
            "$ref": "#/definitions/ActSetItemAttributeType"
          }
        },
        "AddCode": {
          "items": {
            "$ref": "#/definitions/ActAddCodeType"
          }
        },
        "Inject": {
          "items": {
            "$ref": "#/definitions/ActInjectType"
          }
        },
        "ShowURL": {
          "items": {
            "$ref": "#/definitions/CallFuncType"
          }
        },
        "Save": {
          "items": {
            "$ref": "#/definitions/ActSaveResponsesType"
          }
        },
        "SendReport": {
          "items": {
            "$ref": "#/definitions/ActSendReportType"
          }
        },
        "SendMessage111": {
          "items": {
            "$ref": "#/definitions/ActSendMessageType"
          }
        },
        "SetItemAttributeValue": {
          "items": {
            "$ref": "#/definitions/ActSetItemAttributeType"
          }
        },
        "SetAttributeValue": {
          "items": {
            "$ref": "#/definitions/ActSetAttrValueType"
          }
        },
        "SetBoolValue": {
          "items": {
            "$ref": "#/definitions/ActSetValueBoolType"
          }
        },
        "ShowForm": {
          "items": {
            "$ref": "#/definitions/ActShowFormType"
          }
        },
        "ShowMessage": {
          "items": {
            "$ref": "#/definitions/ActShowMessageType"
          }
        },
        "ShowReport": {
          "items": {
            "$ref": "#/definitions/ActShowReportType"
          }
        },
        "PreviewReport": {
          "items": {
            "$ref": "#/definitions/ActPreviewReportType"
          }
        },
        "ValidateForm": {
          "items": {
            "$ref": "#/definitions/ActValidateFormType"
          }
        },
        "RunCode": {
          "items": {
            "$ref": "#/definitions/ScriptCodeAnyType"
          }
        },
        "CallCode": {
          "items": {
            "$ref": "#/definitions/CallFuncType"
          }
        },
        "ConditionalGroupAction": {
          "items": {
            "$ref": "#/definitions/ConditionalGroupActionType"
          }
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "RuleAutoSelectType": {
      "description": "This Rule selects/unselects ListItems based on the selected status of other ListItems.  This declarative rule determines (guards) when target ListItems should be selected or unselected. The guard rule may optionally select/unselect multiple target ListItems with a single rule. The target ListItem(s) to select/unselect are listed in targetNameSelectList.  In the simplest case, this rule operates as follows: A list of ListItems is provided (selectedItemWatchList). If all the items in the list are selected (or unselected - see below) as specified in the selectedItemWatchList list, then the guard evaluates to true, and the targetNameSelectList items are selected.  In some cases, we may wish to watch unselected items in the selectedItemWatchList. This is indicated by prefixing the name of the watched item with a minus sign/dash (\"-\").  In some cases, we may wish to unselect items in the targetNameSelectList list when the selectedItemWatchList evaluated to true. In this case, the target item is prefixed with a dash (\"-\").",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "not": {
          "type": "boolean"
        },
        "boolOp": {
          "description": "Boolean operator that joins together the truth values from each object in the Predicate.",
          "type": "string",
          "enum": [
            "AND",
            "OR",
            "XOR"
          ]
        },
        "selectedItemSet": {
          "description": "This list contains names of ListItems (answer choices) that are watched for being selected or unselected.  If a ListItem appears in this list, then it evaluates to true when it is selected. If a ListItem is prefixed with a hyphen (-), then it evaluates to true when unselected. These Boolean values, derived from each named ListItem in the list, are ANDed together (by default) to produce a return value of true or false. The default Boolean operator (AND) may be changed using @boolOp. If @not = true, then the Boolean result is logically negated.  Renamed from: ListItemSelections",
          "type": "string"
        },
        "onlyIf": {
          "description": "(reversible); If onlyIf is true, then the stipulated Boolean actions, which are executed when the If conditions evaluate to true, are reversed when the conditions evaluate to false.  If onlyIf=\"true\", the target items assume the chosen attribute values (e.g., selected, activated) ONLY when the action condition(s) are satisfied. If the conditions are not satisfied, then all Boolean actions assume the opposite state (e.g., unselected, inactive).  Manually changing the attributes on the target item (upon which the actions are executed) will not affect any attributes in the controlling items. It is possible to disable (enabled=\"false\") the target item so that its attributes can only be be changed programmatically.  The default value is \"false\" indicating that the the rule runs when the \"If\" condition is \"true.\" The attached action will not reverse (be undone) when the \"If\" condition evaluates to \"false.\"",
          "type": "boolean"
        },
        "targetNameSelectList": {
          "description": "This list contains the @names of ListItems that will be automatically selected or deselected when the @selectedItemSet evaluates to true. If a @name is prefixed with a hyphen (-), then the item will be deselected when @selectedItemSet evaluates to true. If @not = true, then the Boolean rule evaluation is negated, and thus the rule works in reverse.  If @onlyIf is true, then the above rule is reversed when @selectedItemSet evaluates to false. In other words, named items will be deselected, and hyphen-prefixed items will be selected when @selectedItemSet is false.",
          "type": "string"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "selectedItemSet"
      ]
    },
    "RuleAutoActivationType": {
      "description": "This Rule sets the activation status of Items based on the selection status of other ListItems.  This declarative rule determines (guards) when target Items should be activated or deactivated. The rule may optionally activate/deactivate multiple target items with a single rule. The target item(s) to activate/deactivate are listed in targetNameList.  In the simplest case, this rule operates as follows: A list of ListItems is provided (selectedItemWatchList). If all the items in the list are selected (or unselected - see below) as specified in the selectedItemWatchList list, then the guard evaluates to true, and the targetNameList items are activated/deactivated.  In some cases, we may wish to watch unselected items in the selectedItemWatchList. This is indicated by prefixing the name of the watched item with a minus sign/dash (\"-\").  In some cases, we may wish to deactivate items in the targetNameSelectList list when the selectedItemWatchList evaluated to true. In this case, the target item is prefixed with a dash (\"-\").",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "not": {
          "type": "boolean"
        },
        "boolOp": {
          "description": "Boolean operator that joins together the truth values from each object in the Predicate.",
          "type": "string",
          "enum": [
            "AND",
            "OR",
            "XOR"
          ]
        },
        "selectedItemSet": {
          "description": "This list contains names of ListItems (answer choices) that are watched for being selected or unselected.  If a ListItem appears in this list, then it evaluates to true when it is selected. If a ListItem is prefixed with a hyphen (-), then it evaluates to true when unselected. These Boolean values, derived from each named ListItem in the list, are ANDed together (by default) to produce a return value of true or false. The default Boolean operator (AND) may be changed using @boolOp. If @not = true, then the Boolean result is logically negated.  Renamed from: ListItemSelections",
          "type": "string"
        },
        "onlyIf": {
          "description": "(reversible); If onlyIf is true, then the stipulated Boolean actions, which are executed when the If conditions evaluate to true, are reversed when the conditions evaluate to false.  If onlyIf=\"true\", the target items assume the chosen attribute values (e.g., selected, activated) ONLY when the action condition(s) are satisfied. If the conditions are not satisfied, then all Boolean actions assume the opposite state (e.g., unselected, inactive).  Manually changing the attributes on the target item (upon which the actions are executed) will not affect any attributes in the controlling items. It is possible to disable (enabled=\"false\") the target item so that its attributes can only be be changed programmatically.  The default value is \"false\" indicating that the the rule runs when the \"If\" condition is \"true.\" The attached action will not reverse (be undone) when the \"If\" condition evaluates to \"false.\"",
          "type": "boolean"
        },
        "targetNameActivationList": {
          "description": "This list contains the @names of Identified Items that will be automatically activated or deactivated when the @selectedItemSet evaluates to true.   If a @name is prefixed with a hyphen (-), then the item will be deactivated when @selectedItemSet evaluates to true. If @not = true, then the Boolean rule evaluation is negated, and thus the rule works in reverse.  If @onlyIf is true, then the above rule is reversed when @selectedItemSet evaluates to false. In other words, named items will be deactivated, and hyphen-prefixed items will be activated when @selectedItemSet is false.",
          "type": "string"
        },
        "setVisibility": {
          "$ref": "#/definitions/toggleType"
        },
        "setEnabled": {
          "$ref": "#/definitions/toggleType"
        },
        "setExpanded": {
          "$ref": "#/definitions/toggleType"
        },
        "removeResponsesWhenDeactivated": {
          "description": "Delete all user selections, responses and comments when the item is deactivated. Applies to all descendant items as well. User should be warned before deleting anything, with an option to preserve the responses in the disabled items. Disabled item responses should not be saved with the form data.",
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "selectedItemSet"
      ]
    },
    "RuleSelectionTestType": {
      "description": "This Rule specifies a set of ListItems that cannot be selected (@listItemNames) when a test ListItem (@testItemName) is selected.   If any selection occurs in @listItemNames when @testItemName is selected, the rule evaluate to true. In all other cases, the rule evaluates to false.  Multiple selections in @listItemNames are acceptable as long as @testItemName is unselected, and in this case, the rule evaluates to false.  \"Legal\" (allowed) selections evaluate to false \"Illegal\" selections evaluate to true These values can be reversed if @not is set to true  Renamed from: IllegalSelectionTest",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "testItemName": {
          "description": "The ListItem that is being evaluated for the presence of disallowed selections (in @listItemNames). This attributes contains the @name of one ListItem.",
          "type": "string"
        },
        "listItemNames": {
          "description": "Set of @name references for a set ListItems, delimited by spaces.",
          "type": "string"
        },
        "not": {
          "description": "If @not=\"true\" then the logical value of the conditions of the parent element is negated; true becomes false and false becomes true.",
          "type": "boolean"
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "testItemName",
        "listItemNames"
      ]
    },
    "RuleSingleSelectionSetsType": {
      "description": "This Rule restricts combinations of co-selected ListItems (answers). In other words, only zero or one item in the @listItemNames list may be selected at a time.   In most cases, all ListItems should be children of a single multi-select question.   Legal (\"allowed\") selections evaluate to false Illegal selections evaluate to true These values can be reversed if @not is set to true  Renamed from: IllegalSelectionSets",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "listItemNames": {
          "description": "Set of @name references for a set ListItems, delimited by spaces.",
          "type": "string"
        },
        "not": {
          "description": "If @not=\"true\" then the logical value of the conditions of the parent element is negated; true becomes false and false becomes true.",
          "type": "boolean"
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "listItemNames"
      ]
    },
    "MultiSelectionSetBoolType": {
      "description": "This Rule component evaluates the @selected status of any set of ListItems at runtime, and returns a true or false value based on the @selected status of each ListItem.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "not": {
          "type": "boolean"
        },
        "boolOp": {
          "description": "Boolean operator that joins together the truth values from each object in the Predicate.",
          "type": "string",
          "enum": [
            "AND",
            "OR",
            "XOR"
          ]
        },
        "selectedItemSet": {
          "description": "This list contains names of ListItems (answer choices) that are watched for being selected or unselected.  If a ListItem appears in this list, then it evaluates to true when it is selected. If a ListItem is prefixed with a hyphen (-), then it evaluates to true when unselected. These Boolean values, derived from each named ListItem in the list, are ANDed together (by default) to produce a return value of true or false. The default Boolean operator (AND) may be changed using @boolOp. If @not = true, then the Boolean result is logically negated.  Renamed from: ListItemSelections",
          "type": "string"
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "selectedItemSet"
      ]
    },
    "GetItemAttribValuesType": {
      "description": "This Rule evaluates an arbitrary set of attribute values from any item and returns a Boolean summary value.  In the PropertyValues condition, the contained Boolean attributed values are ANDed together (by default) to return a derived Boolean value. Default values are used if the attribute is not explicitly set to a value. For attributes without default values, omitted (null) values are ignored and are not used for null propagation.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "ScriptBoolFunc": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScriptCodeBoolType"
          }
        },
        "CallBoolFunc": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CallBoolFuncType"
          }
        },
        "Group": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/GetItemAttribValuesType"
          },
          "minItems": 1
        },
        "not": {
          "type": "boolean"
        },
        "boolOp": {
          "description": "Boolean operator that joins together the truth values from each object in the Predicate.",
          "type": "string",
          "enum": [
            "AND",
            "OR",
            "XOR"
          ]
        },
        "itemNames": {
          "description": "Required name(s) of the item(s) (Section, Question, List Item) that contains the item properties used in the other attributes.",
          "type": "string"
        },
        "isSelected": {
          "type": "boolean"
        },
        "isActive": {
          "description": "If visible and enabled are both true, then isActive is true. Otherwise, it is false.",
          "type": "boolean"
        },
        "hasSelectionsGTE": {
          "description": "Applies only to Questions that have selection lists (ListItems or LookupField). Evaluates to true if the number of selected items equals or exceeds the entered value.",
          "type": "integer"
        },
        "hasSelectionsLTE": {
          "description": "Applies only to Questions that have selection lists (ListItems or LookupField). Evaluates to true if the number of selected items is less than or equal to the entered value.",
          "type": "integer"
        },
        "hasSelectionsExact": {
          "description": "Applies only to Questions that have selection lists (ListItems or LookupField). Evaluates to true if the number of selected items equals the entered value.",
          "type": "integer"
        },
        "hasResponse": {
          "description": "Applies only to items that have Response Fields (Questions and ListItems). If the ListItem or Question has a Response Field, and that field has a value in it, this property returns true. If it does not have a value, it returns false. If no Response Field is present, it retuns null and is not used for Boolean comparisons.",
          "type": "boolean"
        },
        "isVisible": {
          "type": "boolean"
        },
        "isEnabled": {
          "type": "boolean"
        },
        "isRequired": {
          "description": "If the minCard value is greater than 0, then isRequired = \"true\"  If the minCard = \"0\" then isRequired = \"false\"",
          "type": "boolean"
        },
        "isReadOnly": {
          "type": "boolean"
        },
        "hasType": {
          "type": "string"
        },
        "hasStyleClass": {
          "type": "string"
        },
        "hasValueEQ": {
          "type": "integer"
        },
        "hasValueLT": {
          "type": "integer"
        },
        "hasValueLTE": {
          "type": "integer"
        },
        "hasValueGT": {
          "type": "integer"
        },
        "hasValueGTE": {
          "type": "integer"
        },
        "hasAssociatedValue": {
          "description": "Applies only to ListItems. If the attribute has a value in it, this property returns true. If it does not have a value, it returns false.",
          "type": "boolean"
        },
        "hasAssociatedValueEQ": {
          "type": "integer"
        },
        "hasAssociatedValueLT": {
          "type": "integer"
        },
        "hasAssociatedValueLTE": {
          "type": "integer"
        },
        "hasAssociatedValueGT": {
          "type": "integer"
        },
        "hasAssociatedValueGTE": {
          "type": "integer"
        },
        "supportdatesandIntervals": {
          "type": [
            "string",
            "number",
            "boolean"
          ]
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      },
      "required": [
        "itemNames"
      ]
    },
    "AlternativesType": {
      "description": "This Rule tests if one (or more) items in a list of items has received a a valid user response (answer).   In the simplest case, this Rule allows a user to answer only one of several alternative questions (named in the @itemNames list), and still save a successfully-validated form. In more complex cases, a user can be required to produce a valid response to a specific minimum and maximum number of Questions, Sections, ListItems or Injected parts.   The minCard value on each of the alternative items should be set to \"0\" (i.e., optional) to avoid validation conflicts when minCard greater than 0.  The list of Item @name values is contained in @itemNames. The list must contain at least 2 @name values.  The minimum number of items to answer is contained in @minAnswered (default value = 1).   If there is a maximum number of items to answer, the value is contained in @maxAnswered (default value = 0 meaning unlimited).",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "not": {
          "description": "If @not=\"true\" then the logical value of the conditions of the parent element is negated; true becomes false and false becomes true.",
          "type": "boolean"
        },
        "minAnswered": {
          "type": "integer"
        },
        "maxAnswered": {
          "description": "@maxAnswered must be 0 or greater than or equal to @minAnswered.",
          "type": "integer"
        },
        "itemNames": {
          "description": "List of names of Sections, Questions, ListItems and/or InjectedItems. Each of the named items will evaluate to true or false, based on the following validation rules:  If the name points to a Section, then the Section evaluates to true (valid) if all of its descendant items are answered correctly, according to their metadata.  If the name points to a Question then the Question evaluates to true (valid) if it is correctly answered according to its metadata, and also, all descendant items are answered correctly, according to their metadata.  If the name points to a ListItem then the ListItem evaluates to true (valid) if it is selected, and also, all descendant items are answered correctly according to their metadata.  If the name points to an InjectedItem then the InjectedItem evaluates to true (valid) if all descendant items are answered correctly, according to their metadata.  The number of true responses are added together. If they satisfy the minAnswered and maxAnswered attribute values, then this type returns true. Otherwise it returns false.",
          "type": "string"
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "GuardType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "AttributeCondition": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/GetItemAttribValuesType"
          }
        },
        "MultiSelections": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MultiSelectionSetBoolType"
          }
        },
        "IllegalSelectionTest": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleSelectionTestType"
          }
        },
        "IllegalSelectionSets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleSingleSelectionSetsType"
          }
        },
        "ItemAlternatives": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AlternativesType"
          }
        },
        "ScriptCondition": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScriptCodeBoolType"
          }
        },
        "CallBoolCondition": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CallBoolFuncType"
          }
        },
        "Group": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/GuardType"
          }
        },
        "not": {
          "type": "boolean"
        },
        "boolOp": {
          "description": "Boolean operator that joins together the truth values from each object in the Predicate.",
          "type": "string",
          "enum": [
            "AND",
            "OR",
            "XOR"
          ]
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "ConditionsSubActionsType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "AttributeCondition": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "ScriptBoolFunc": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ScriptCodeBoolType"
                }
              },
              "CallBoolFunc": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CallBoolFuncType"
                }
              },
              "Group": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/GetItemAttribValuesType"
                },
                "minItems": 1
              },
              "Actions": {
                "$ref": "#/definitions/ActionsType"
              },
              "not": {
                "type": "boolean"
              },
              "boolOp": {
                "description": "Boolean operator that joins together the truth values from each object in the Predicate.",
                "type": "string",
                "enum": [
                  "AND",
                  "OR",
                  "XOR"
                ]
              },
              "itemNames": {
                "description": "Required name(s) of the item(s) (Section, Question, List Item) that contains the item properties used in the other attributes.",
                "type": "string"
              },
              "isSelected": {
                "type": "boolean"
              },
              "isActive": {
                "description": "If visible and enabled are both true, then isActive is true. Otherwise, it is false.",
                "type": "boolean"
              },
              "hasSelectionsGTE": {
                "description": "Applies only to Questions that have selection lists (ListItems or LookupField). Evaluates to true if the number of selected items equals or exceeds the entered value.",
                "type": "integer"
              },
              "hasSelectionsLTE": {
                "description": "Applies only to Questions that have selection lists (ListItems or LookupField). Evaluates to true if the number of selected items is less than or equal to the entered value.",
                "type": "integer"
              },
              "hasSelectionsExact": {
                "description": "Applies only to Questions that have selection lists (ListItems or LookupField). Evaluates to true if the number of selected items equals the entered value.",
                "type": "integer"
              },
              "hasResponse": {
                "description": "Applies only to items that have Response Fields (Questions and ListItems). If the ListItem or Question has a Response Field, and that field has a value in it, this property returns true. If it does not have a value, it returns false. If no Response Field is present, it retuns null and is not used for Boolean comparisons.",
                "type": "boolean"
              },
              "isVisible": {
                "type": "boolean"
              },
              "isEnabled": {
                "type": "boolean"
              },
              "isRequired": {
                "description": "If the minCard value is greater than 0, then isRequired = \"true\"  If the minCard = \"0\" then isRequired = \"false\"",
                "type": "boolean"
              },
              "isReadOnly": {
                "type": "boolean"
              },
              "hasType": {
                "type": "string"
              },
              "hasStyleClass": {
                "type": "string"
              },
              "hasValueEQ": {
                "type": "integer"
              },
              "hasValueLT": {
                "type": "integer"
              },
              "hasValueLTE": {
                "type": "integer"
              },
              "hasValueGT": {
                "type": "integer"
              },
              "hasValueGTE": {
                "type": "integer"
              },
              "hasAssociatedValue": {
                "description": "Applies only to ListItems. If the attribute has a value in it, this property returns true. If it does not have a value, it returns false.",
                "type": "boolean"
              },
              "hasAssociatedValueEQ": {
                "type": "integer"
              },
              "hasAssociatedValueLT": {
                "type": "integer"
              },
              "hasAssociatedValueLTE": {
                "type": "integer"
              },
              "hasAssociatedValueGT": {
                "type": "integer"
              },
              "hasAssociatedValueGTE": {
                "type": "integer"
              },
              "supportdatesandIntervals": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              },
              "allowNull": {
                "type": "boolean"
              },
              "validationMessage": {
                "description": "Optional message that appears when the rule evaluates to true",
                "type": "string"
              },
              "val": {
                "type": "boolean"
              },
              "name": {
                "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
                "type": "string"
              },
              "order": {
                "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
                "type": "integer",
                "minimum": 0.0
              }
            },
            "required": [
              "itemNames"
            ]
          }
        },
        "MultiSelections": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "Actions": {
                "$ref": "#/definitions/ActionsType"
              },
              "not": {
                "type": "boolean"
              },
              "boolOp": {
                "description": "Boolean operator that joins together the truth values from each object in the Predicate.",
                "type": "string",
                "enum": [
                  "AND",
                  "OR",
                  "XOR"
                ]
              },
              "selectedItemSet": {
                "description": "This list contains names of ListItems (answer choices) that are watched for being selected or unselected.  If a ListItem appears in this list, then it evaluates to true when it is selected. If a ListItem is prefixed with a hyphen (-), then it evaluates to true when unselected. These Boolean values, derived from each named ListItem in the list, are ANDed together (by default) to produce a return value of true or false. The default Boolean operator (AND) may be changed using @boolOp. If @not = true, then the Boolean result is logically negated.  Renamed from: ListItemSelections",
                "type": "string"
              },
              "allowNull": {
                "type": "boolean"
              },
              "validationMessage": {
                "description": "Optional message that appears when the rule evaluates to true",
                "type": "string"
              },
              "val": {
                "type": "boolean"
              },
              "name": {
                "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
                "type": "string"
              },
              "order": {
                "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
                "type": "integer",
                "minimum": 0.0
              }
            },
            "required": [
              "selectedItemSet"
            ]
          }
        },
        "IllegalSelectionSets": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "Actions": {
                "$ref": "#/definitions/ActionsType"
              },
              "listItemNames": {
                "description": "Set of @name references for a set ListItems, delimited by spaces.",
                "type": "string"
              },
              "not": {
                "description": "If @not=\"true\" then the logical value of the conditions of the parent element is negated; true becomes false and false becomes true.",
                "type": "boolean"
              },
              "allowNull": {
                "type": "boolean"
              },
              "validationMessage": {
                "description": "Optional message that appears when the rule evaluates to true",
                "type": "string"
              },
              "val": {
                "type": "boolean"
              },
              "name": {
                "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
                "type": "string"
              },
              "order": {
                "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
                "type": "integer",
                "minimum": 0.0
              }
            },
            "required": [
              "listItemNames"
            ]
          }
        },
        "IllegalSelectionTest": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "Actions": {
                "$ref": "#/definitions/ActionsType"
              },
              "testItemName": {
                "description": "The ListItem that is being evaluated for the presence of disallowed selections (in @listItemNames). This attributes contains the @name of one ListItem.",
                "type": "string"
              },
              "listItemNames": {
                "description": "Set of @name references for a set ListItems, delimited by spaces.",
                "type": "string"
              },
              "not": {
                "description": "If @not=\"true\" then the logical value of the conditions of the parent element is negated; true becomes false and false becomes true.",
                "type": "boolean"
              },
              "allowNull": {
                "type": "boolean"
              },
              "validationMessage": {
                "description": "Optional message that appears when the rule evaluates to true",
                "type": "string"
              },
              "val": {
                "type": "boolean"
              },
              "name": {
                "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
                "type": "string"
              },
              "order": {
                "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
                "type": "integer",
                "minimum": 0.0
              }
            },
            "required": [
              "testItemName",
              "listItemNames"
            ]
          }
        },
        "ScriptCondition": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "Parameter": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ParameterItemType"
                }
              },
              "Actions": {
                "$ref": "#/definitions/ActionsType"
              },
              "language": {
                "description": "Programming language.",
                "type": "string"
              },
              "code": {
                "description": "Script contents.",
                "type": "string"
              },
              "allowNull": {
                "type": "boolean"
              },
              "validationMessage": {
                "description": "Optional message that appears when the rule evaluates to true",
                "type": "string"
              },
              "val": {
                "type": "boolean"
              },
              "name": {
                "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
                "type": "string"
              },
              "order": {
                "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
                "type": "integer",
                "minimum": 0.0
              }
            }
          }
        },
        "Group": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ConditionalGroupActionType"
          }
        },
        "not": {
          "type": "boolean"
        },
        "boolOp": {
          "description": "Boolean operator that joins together the truth values from each object in the Predicate.",
          "type": "string",
          "enum": [
            "AND",
            "OR",
            "XOR"
          ]
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "ConditionalGroupActionType": {
      "description": "Execute an Action based when the Boolean condition returns true.  Boolean sub-Conditions and sub-Actions may be nested to any level.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Conditions": {
          "items": {
            "$ref": "#/definitions/ConditionsSubActionsType"
          }
        },
        "Actions": {
          "items": {
            "$ref": "#/definitions/ActionsType"
          }
        },
        "allowNull": {
          "type": "boolean"
        },
        "validationMessage": {
          "description": "Optional message that appears when the rule evaluates to true",
          "type": "string"
        },
        "val": {
          "type": "boolean"
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    },
    "RulesType": {
      "description": "Rules are procedures that affect form behaviour. They are usually triggered by changes to the form by a form user. They may also be triggered by other rules or changes to form metadata (e.g., change to @visible).  SDC decarative form rules consist of several types:  Assertions are \"predicate\" expressions that evaulate to true or false, based upon the state of answers/responses or metadata within a form. An asserion is equivalent to the \"If\" part of an If-Then block. The implementation framework must assign a fucntion to handle any assertion that evaluates to False. Assertions are no handled by the form itself.  If-Then-Else blocks run a \"Then\" action if the \"If block evaluated to true, and an \"Else\" block if the \"If\" block evaluates to false.  An AutoSelection rule automatically selects an answer choice (ListItem) when another answer (or set of answers) is selected or unselected.  IllegalSelectionTest evaluates to true if a disallowed set of answer choices is selected at the same time. The implementation should take an action (alert user, cancel inout, etc) when a true result occurs.  IllegalSelection Set restricts combinations of co-selected ListItems (answers). In other words, only zero or one item in this list may be selected at a time.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Validation": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "Comment": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/CommentType"
              }
            },
            "Extension": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ExtensionType"
              }
            },
            "Property": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/PropertyType"
              }
            },
            "IllegalSelectionTest": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/RuleSelectionTestType"
                }
              }
            },
            "IllegalSelectionSets": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/RuleSingleSelectionSetsType"
                }
              }
            },
            "ItemAlternatives": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/AlternativesType"
                }
              }
            },
            "name": {
              "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
              "type": "string"
            },
            "type": {
              "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
              "type": "string"
            },
            "styleClass": {
              "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
              "type": "string"
            },
            "order": {
              "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
              "type": "integer",
              "minimum": 0.0
            }
          }
        },
        "AutoActivation": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleAutoActivationType"
          }
        },
        "AutoSelection": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleAutoSelectType"
          }
        },
        "ConditionalGroupActions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ConditionalGroupActionType"
          }
        },
        "ScriptedRule": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScriptCodeAnyType"
          }
        },
        "ExternalRule": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CallFuncType"
          }
        },
        "name": {
          "description": "Developer assigned identifier, similar to a unique control/object  name, used to provide the ability for programmatic manipulation of an  element.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the  element, chosen from a standardized list of terms. Tokens are short alphanumeric  text strings, defined by the W3C Schema NMTOKEN specification, that are defined  in an Implementation Guide. The type xsd:NMTOKEN represents a single string  token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( -  ), underscores ( _ ), and colons ( : ). They may start with any of these  characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be  specific for one or more kinds of SDC elements. Multiple tokens in the type  attribute should be separated by whitespace. Type tokens may be used to specify  special handling by an application, and are usually used to define form display  constraints, but may include other custom metadata as well. Style metadata  should generally be handled with @styleClass rather than @type. @type token  examples include: tooltip, statusLineText, alignTopLeft, align:bottom,  _pageBreak-after, etc. @type metadata should generally not affect the  information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "Developer assigned class name for display styling, generally for  use with an external style sheet.",
          "type": "string"
        },
        "order": {
          "description": "@order allows the form template developer to define a sequential  order for elements in a template. This serves the purpose of providing a  definitive/original order to sections, questions, answer choices, etc., when  required for display purposes. This is important when the original XML ordering  may become disrupted due to the use of an implementation technology that does  not natively support ordering (e.g., object collections), and it can also  provide a check on the proper importing of the XML tree during  implementation.",
          "type": "integer",
          "minimum": 0.0
        }
      }
    }
  },
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "dt": {
      "description": "A dummy \"data type\" (dt) element to compensate for a code generator bug. Do not use this type for anything.",
      "type": "object",
      "additionalProperties": false
    },
    "FormDesign": {
      "$ref": "#/definitions/FormDesignType"
    },
    "DataElement": {
      "$ref": "#/definitions/DataElementType"
    }
  }
}