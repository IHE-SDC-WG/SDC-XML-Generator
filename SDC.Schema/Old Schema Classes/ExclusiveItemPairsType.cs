// ------------------------------------------------------------------------------
//  <auto-generated>
//    Generated by Xsd2Code++. Version 4.2.0.31
//  </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable
namespace SDC
{
using System;
using System.Diagnostics;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;
using System.IO;
using System.Text;
using System.ComponentModel.DataAnnotations;
using System.Xml;
using System.Collections.Generic;

/// <summary>
/// A shortcut approach to specify ListItems that cannot be selected together because they would not make logical sense, e.g., Present and Not Present.  None of the ListItems in the list may be selected when any other ListItem in the ExclusiveSet is selected.  In other words, this structure can be used to specify mutually exclusive pairings of selected ListItems.
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.6.1067.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://healthIT.gov/sdc")]
public partial class ExclusiveItemPairsType : ExtensionBaseType
{
    
    private bool _shouldSerializenot;
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    private bool _not;
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    private string _testItemName;
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    private string _exclusiveSet;
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    private string _validationMessage;
    
    private static XmlSerializer serializer;
    
    /// <summary>
    /// ExclusiveItemPairsType class constructor
    /// </summary>
    public ExclusiveItemPairsType()
    {
        this._not = false;
    }
    
    /// <summary>
    /// If @not="true" then the logical value of the conditions of the parent element is negated; true becomes false and false becomes true.
    /// </summary>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    [System.ComponentModel.DefaultValueAttribute(false)]
    public virtual bool not
    {
        get
        {
            return this._not;
        }
        set
        {
            this._not = value;
            _shouldSerializenot = true;
        }
    }
    
    /// <summary>
    /// The ListItem that is being evaluated for the presence of disallowed selections (in @exclusiveSet)
    /// </summary>
    [System.Xml.Serialization.XmlAttributeAttribute(DataType="NCName")]
    public virtual string testItemName
    {
        get
        {
            return this._testItemName;
        }
        set
        {
            this._testItemName = value;
        }
    }
    
    /// <summary>
    /// If no @testItemName is present, then this attribute contains ListItems that  may not be selected together in any combination. IF any 2 of them are selected, then the parent element (ExclusiveSelectedItems) evaluates to true.
    /// 
    /// If @testItemName has a value and is selected, then the items in @exclusiveSet are evaluated to see if any of them are also selected.  If one or more is also selected, then the parent element (ExclusiveSelectedItems) evaluates to true.
    /// 
    /// If @testItemName has a value, the @exclusiveSet items are not tested against each other.
    /// </summary>
    [System.Xml.Serialization.XmlAttributeAttribute(DataType="NMTOKENS")]
    public virtual string exclusiveSet
    {
        get
        {
            return this._exclusiveSet;
        }
        set
        {
            this._exclusiveSet = value;
        }
    }
    
    /// <summary>
    /// Message that appears when an illegal combination of ListItems is selected.
    /// </summary>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public virtual string validationMessage
    {
        get
        {
            return this._validationMessage;
        }
        set
        {
            this._validationMessage = value;
        }
    }
    
    private static XmlSerializer Serializer
    {
        get
        {
            if ((serializer == null))
            {
                serializer = new XmlSerializerFactory().CreateSerializer(typeof(ExclusiveItemPairsType));
            }
            return serializer;
        }
    }
    
    /// <summary>
    /// Test whether not should be serialized
    /// </summary>
    public virtual bool ShouldSerializenot()
    {
        if (_shouldSerializenot)
        {
            return true;
        }
        return (_not != default(bool));
    }
    
    /// <summary>
    /// Test whether testItemName should be serialized
    /// </summary>
    public virtual bool ShouldSerializetestItemName()
    {
        return !string.IsNullOrEmpty(testItemName);
    }
    
    /// <summary>
    /// Test whether exclusiveSet should be serialized
    /// </summary>
    public virtual bool ShouldSerializeexclusiveSet()
    {
        return !string.IsNullOrEmpty(exclusiveSet);
    }
    
    /// <summary>
    /// Test whether validationMessage should be serialized
    /// </summary>
    public virtual bool ShouldSerializevalidationMessage()
    {
        return !string.IsNullOrEmpty(validationMessage);
    }
    
    #region Serialize/Deserialize
    /// <summary>
    /// Serializes current ExclusiveItemPairsType object into an XML string
    /// </summary>
    /// <returns>string XML value</returns>
    public virtual string Serialize()
    {
        System.IO.StreamReader streamReader = null;
        System.IO.MemoryStream memoryStream = null;
        try
        {
            memoryStream = new System.IO.MemoryStream();
            System.Xml.XmlWriterSettings xmlWriterSettings = new System.Xml.XmlWriterSettings();
            xmlWriterSettings.Indent = true;
            System.Xml.XmlWriter xmlWriter = XmlWriter.Create(memoryStream, xmlWriterSettings);
            Serializer.Serialize(xmlWriter, this);
            memoryStream.Seek(0, System.IO.SeekOrigin.Begin);
            streamReader = new System.IO.StreamReader(memoryStream);
            return streamReader.ReadToEnd();
        }
        finally
        {
            if ((streamReader != null))
            {
                streamReader.Dispose();
            }
            if ((memoryStream != null))
            {
                memoryStream.Dispose();
            }
        }
    }
    
    /// <summary>
    /// Deserializes workflow markup into an ExclusiveItemPairsType object
    /// </summary>
    /// <param name="input">string workflow markup to deserialize</param>
    /// <param name="obj">Output ExclusiveItemPairsType object</param>
    /// <param name="exception">output Exception value if deserialize failed</param>
    /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
    public static bool Deserialize(string input, out ExclusiveItemPairsType obj, out System.Exception exception)
    {
        exception = null;
        obj = default(ExclusiveItemPairsType);
        try
        {
            obj = Deserialize(input);
            return true;
        }
        catch (System.Exception ex)
        {
            exception = ex;
            return false;
        }
    }
    
    public static bool Deserialize(string input, out ExclusiveItemPairsType obj)
    {
        System.Exception exception = null;
        return Deserialize(input, out obj, out exception);
    }
    
    public new static ExclusiveItemPairsType Deserialize(string input)
    {
        System.IO.StringReader stringReader = null;
        try
        {
            stringReader = new System.IO.StringReader(input);
            return ((ExclusiveItemPairsType)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
        }
        finally
        {
            if ((stringReader != null))
            {
                stringReader.Dispose();
            }
        }
    }
    
    public static ExclusiveItemPairsType Deserialize(System.IO.Stream s)
    {
        return ((ExclusiveItemPairsType)(Serializer.Deserialize(s)));
    }
    #endregion
    
    /// <summary>
    /// Serializes current ExclusiveItemPairsType object into file
    /// </summary>
    /// <param name="fileName">full path of outupt xml file</param>
    /// <param name="exception">output Exception value if failed</param>
    /// <returns>true if can serialize and save into file; otherwise, false</returns>
    public virtual bool SaveToFile(string fileName, out System.Exception exception)
    {
        exception = null;
        try
        {
            SaveToFile(fileName);
            return true;
        }
        catch (System.Exception e)
        {
            exception = e;
            return false;
        }
    }
    
    public virtual void SaveToFile(string fileName)
    {
        System.IO.StreamWriter streamWriter = null;
        try
        {
            string xmlString = Serialize();
            System.IO.FileInfo xmlFile = new System.IO.FileInfo(fileName);
            streamWriter = xmlFile.CreateText();
            streamWriter.WriteLine(xmlString);
            streamWriter.Close();
        }
        finally
        {
            if ((streamWriter != null))
            {
                streamWriter.Dispose();
            }
        }
    }
    
    /// <summary>
    /// Deserializes xml markup from file into an ExclusiveItemPairsType object
    /// </summary>
    /// <param name="fileName">string xml file to load and deserialize</param>
    /// <param name="obj">Output ExclusiveItemPairsType object</param>
    /// <param name="exception">output Exception value if deserialize failed</param>
    /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
    public static bool LoadFromFile(string fileName, out ExclusiveItemPairsType obj, out System.Exception exception)
    {
        exception = null;
        obj = default(ExclusiveItemPairsType);
        try
        {
            obj = LoadFromFile(fileName);
            return true;
        }
        catch (System.Exception ex)
        {
            exception = ex;
            return false;
        }
    }
    
    public static bool LoadFromFile(string fileName, out ExclusiveItemPairsType obj)
    {
        System.Exception exception = null;
        return LoadFromFile(fileName, out obj, out exception);
    }
    
    public new static ExclusiveItemPairsType LoadFromFile(string fileName)
    {
        System.IO.FileStream file = null;
        System.IO.StreamReader sr = null;
        try
        {
            file = new System.IO.FileStream(fileName, FileMode.Open, FileAccess.Read);
            sr = new System.IO.StreamReader(file);
            string xmlString = sr.ReadToEnd();
            sr.Close();
            file.Close();
            return Deserialize(xmlString);
        }
        finally
        {
            if ((file != null))
            {
                file.Dispose();
            }
            if ((sr != null))
            {
                sr.Dispose();
            }
        }
    }
}
}
#pragma warning restore
