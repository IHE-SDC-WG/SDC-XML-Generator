// ------------------------------------------------------------------------------
//  <auto-generated>
//    Generated by Xsd2Code++. Version 4.2.0.15
//  </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable
namespace SDC
{
using System;
using System.Diagnostics;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;
using System.Collections.Specialized;
using System.Runtime.Serialization;
using System.Collections.ObjectModel;
using System.Reflection;
using System.IO;
using System.Text;
using System.ComponentModel.DataAnnotations;
using System.Xml;

/// <summary>
/// A shortcut approach to specify ListItems that cannot be selected together because they would not make logical sense, e.g., Present and Not Present.  None of the ListItems in the list may be selected when any other ListItem in the ExclusiveSet is selected.  In other words, this structure can be used to specify mutually exclusive pairings of selected ListItems.
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.6.1067.0")]
[Serializable]
[DebuggerStepThrough]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[XmlTypeAttribute(Namespace="http://healthIT.gov/sdc")]
[DataContractAttribute(Name="ExclusiveItemPairsType", Namespace="http://healthIT.gov/sdc")]
public partial class ExclusiveItemPairsType : ExtensionBaseType
{
    
    private bool _shouldSerializenot;
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    private bool _not;
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    private string _testItemName;
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    private string _exclusiveSet;
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    private string _validationMessage;
    
    private static XmlSerializer serializer;
    
    private ObjectChangeTracker changeTrackerField;
    
    /// <summary>
    /// ExclusiveItemPairsType class constructor
    /// </summary>
    public ExclusiveItemPairsType()
    {
        _not = false;
    }
    
    /// <summary>
    /// If @not="true" then the logical value of the conditions of the parent element is negated; true becomes false and false becomes true.
    /// </summary>
    [XmlAttribute]
    [System.ComponentModel.DefaultValueAttribute(false)]
    [DataMember]
    public virtual bool not
    {
        get
        {
            return _not;
        }
        set
        {
            if ((_not.Equals(value) != true))
            {
                _not = value;
                OnPropertyChanged("not", value);
            }
            _shouldSerializenot = true;
        }
    }
    
    /// <summary>
    /// The ListItem that is being evaluated for the presence of disallowed selections (in @exclusiveSet)
    /// </summary>
    [XmlAttributeAttribute(DataType="NCName")]
    [DataMember]
    public virtual string testItemName
    {
        get
        {
            return _testItemName;
        }
        set
        {
            if ((_testItemName == value))
            {
                return;
            }
            if (((_testItemName == null) 
                        || (_testItemName.Equals(value) != true)))
            {
                _testItemName = value;
                OnPropertyChanged("testItemName", value);
            }
        }
    }
    
    /// <summary>
    /// If no @testItemName is present, then this attribute contains ListItems that  may not be selected together in any combination. IF any 2 of them are selected, then the parent element (ExclusiveSelectedItems) evaluates to true.
    /// 
    /// If @testItemName has a value and is selected, then the items in @exclusiveSet are evaluated to see if any of them are also selected.  If one or more is also selected, then the parent element (ExclusiveSelectedItems) evaluates to true.
    /// 
    /// If @testItemName has a value, the @exclusiveSet items are not tested against each other.
    /// </summary>
    [XmlAttributeAttribute(DataType="NMTOKENS")]
    [DataMember]
    public virtual string exclusiveSet
    {
        get
        {
            return _exclusiveSet;
        }
        set
        {
            if ((_exclusiveSet == value))
            {
                return;
            }
            if (((_exclusiveSet == null) 
                        || (_exclusiveSet.Equals(value) != true)))
            {
                _exclusiveSet = value;
                OnPropertyChanged("exclusiveSet", value);
            }
        }
    }
    
    /// <summary>
    /// Message that appears when an illegal combination of ListItems is selected.
    /// </summary>
    [XmlAttribute]
    [DataMember]
    public virtual string validationMessage
    {
        get
        {
            return _validationMessage;
        }
        set
        {
            if ((_validationMessage == value))
            {
                return;
            }
            if (((_validationMessage == null) 
                        || (_validationMessage.Equals(value) != true)))
            {
                _validationMessage = value;
                OnPropertyChanged("validationMessage", value);
            }
        }
    }
    
    private static XmlSerializer Serializer
    {
        get
        {
            if ((serializer == null))
            {
                serializer = new XmlSerializerFactory().CreateSerializer(typeof(ExclusiveItemPairsType));
            }
            return serializer;
        }
    }
    
    [XmlIgnore()]
    public ObjectChangeTracker ChangeTracker
    {
        get
        {
            if ((changeTrackerField == null))
            {
                changeTrackerField = new ObjectChangeTracker(this);
            }
            return changeTrackerField;
        }
    }
    
    /// <summary>
    /// Test whether not should be serialized
    /// </summary>
    public virtual bool ShouldSerializenot()
    {
        if (_shouldSerializenot)
        {
            return true;
        }
        return (_not != default(bool));
    }
    
    /// <summary>
    /// Test whether testItemName should be serialized
    /// </summary>
    public virtual bool ShouldSerializetestItemName()
    {
        return !string.IsNullOrEmpty(testItemName);
    }
    
    /// <summary>
    /// Test whether exclusiveSet should be serialized
    /// </summary>
    public virtual bool ShouldSerializeexclusiveSet()
    {
        return !string.IsNullOrEmpty(exclusiveSet);
    }
    
    /// <summary>
    /// Test whether validationMessage should be serialized
    /// </summary>
    public virtual bool ShouldSerializevalidationMessage()
    {
        return !string.IsNullOrEmpty(validationMessage);
    }
    
    #region Serialize/Deserialize
    /// <summary>
    /// Serializes current ExclusiveItemPairsType object into an XML string
    /// </summary>
    /// <returns>string XML value</returns>
    public virtual string Serialize()
    {
        StreamReader streamReader = null;
        MemoryStream memoryStream = null;
        try
        {
            memoryStream = new MemoryStream();
            System.Xml.XmlWriterSettings xmlWriterSettings = new System.Xml.XmlWriterSettings();
            xmlWriterSettings.Indent = true;
            System.Xml.XmlWriter xmlWriter = XmlWriter.Create(memoryStream, xmlWriterSettings);
            Serializer.Serialize(xmlWriter, this);
            memoryStream.Seek(0, SeekOrigin.Begin);
            streamReader = new StreamReader(memoryStream);
            return streamReader.ReadToEnd();
        }
        finally
        {
            if ((streamReader != null))
            {
                streamReader.Dispose();
            }
            if ((memoryStream != null))
            {
                memoryStream.Dispose();
            }
        }
    }
    
    /// <summary>
    /// Deserializes workflow markup into an ExclusiveItemPairsType object
    /// </summary>
    /// <param name="input">string workflow markup to deserialize</param>
    /// <param name="obj">Output ExclusiveItemPairsType object</param>
    /// <param name="exception">output Exception value if deserialize failed</param>
    /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
    public static bool Deserialize(string input, out ExclusiveItemPairsType obj, out Exception exception)
    {
        exception = null;
        obj = default(ExclusiveItemPairsType);
        try
        {
            obj = Deserialize(input);
            return true;
        }
        catch (Exception ex)
        {
            exception = ex;
            return false;
        }
    }
    
    public static bool Deserialize(string input, out ExclusiveItemPairsType obj)
    {
        Exception exception = null;
        return Deserialize(input, out obj, out exception);
    }
    
    public new static ExclusiveItemPairsType Deserialize(string input)
    {
        StringReader stringReader = null;
        try
        {
            stringReader = new StringReader(input);
            return ((ExclusiveItemPairsType)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
        }
        finally
        {
            if ((stringReader != null))
            {
                stringReader.Dispose();
            }
        }
    }
    
    public static ExclusiveItemPairsType Deserialize(Stream s)
    {
        return ((ExclusiveItemPairsType)(Serializer.Deserialize(s)));
    }
    #endregion
    
    /// <summary>
    /// Serializes current ExclusiveItemPairsType object into file
    /// </summary>
    /// <param name="fileName">full path of outupt xml file</param>
    /// <param name="exception">output Exception value if failed</param>
    /// <returns>true if can serialize and save into file; otherwise, false</returns>
    public virtual bool SaveToFile(string fileName, out Exception exception)
    {
        exception = null;
        try
        {
            SaveToFile(fileName);
            return true;
        }
        catch (Exception e)
        {
            exception = e;
            return false;
        }
    }
    
    public virtual void SaveToFile(string fileName)
    {
        StreamWriter streamWriter = null;
        try
        {
            string xmlString = Serialize();
            FileInfo xmlFile = new FileInfo(fileName);
            streamWriter = xmlFile.CreateText();
            streamWriter.WriteLine(xmlString);
            streamWriter.Close();
        }
        finally
        {
            if ((streamWriter != null))
            {
                streamWriter.Dispose();
            }
        }
    }
    
    /// <summary>
    /// Deserializes xml markup from file into an ExclusiveItemPairsType object
    /// </summary>
    /// <param name="fileName">string xml file to load and deserialize</param>
    /// <param name="obj">Output ExclusiveItemPairsType object</param>
    /// <param name="exception">output Exception value if deserialize failed</param>
    /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
    public static bool LoadFromFile(string fileName, out ExclusiveItemPairsType obj, out Exception exception)
    {
        exception = null;
        obj = default(ExclusiveItemPairsType);
        try
        {
            obj = LoadFromFile(fileName);
            return true;
        }
        catch (Exception ex)
        {
            exception = ex;
            return false;
        }
    }
    
    public static bool LoadFromFile(string fileName, out ExclusiveItemPairsType obj)
    {
        Exception exception = null;
        return LoadFromFile(fileName, out obj, out exception);
    }
    
    public new static ExclusiveItemPairsType LoadFromFile(string fileName)
    {
        FileStream file = null;
        StreamReader sr = null;
        try
        {
            file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
            sr = new StreamReader(file);
            string xmlString = sr.ReadToEnd();
            sr.Close();
            file.Close();
            return Deserialize(xmlString);
        }
        finally
        {
            if ((file != null))
            {
                file.Dispose();
            }
            if ((sr != null))
            {
                sr.Dispose();
            }
        }
    }
    
    #region Clone method
    /// <summary>
    /// Create a clone of this ExclusiveItemPairsType object
    /// </summary>
    public virtual ExclusiveItemPairsType Clone()
    {
        return ((ExclusiveItemPairsType)(MemberwiseClone()));
    }
    #endregion
}
}
#pragma warning restore
